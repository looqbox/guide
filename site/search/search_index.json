{
    "docs": [
        {
            "location": "/",
            "text": "Home\n\n\n\n  \n\n\n\n\n\nIntroduction\n\n\nInstallation\n\n\nLooqbox must be installed in a Linux distribution that supports docker (e.g. Ubuntu 18.04 LTS).\n\n\nTo start the container, run:\n\n\ndocker run -d --restart=always --name=looqbox-instance -e CLIENT=\"<client name>\" -e KEY=\"<client key>\" -e RSTUDIO_PASS=\"<choose a password>\" -p 80:80 -p 8787:8787 looqboxrep/fes-public:cloud002\n\n\n\n\nAvailable parameters\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-e XMX=\"-Xmx512m\"\n\n\nchange maximum heap\n\n\n\n\n\n\n-e XMS=\"-Xms512m\"\n\n\nchange minimum heap\n\n\n\n\n\n\n-e PORT\n\n\nchange Looqbox's port (default 80)\n\n\n\n\n\n\n-e PROXY_HOST=\"<ip>\"\n\n\nwhen parameter exists, use host as proxy (must define proxy_port as well)\n\n\n\n\n\n\n-e PROXY_PORT=\"<port>\"\n\n\nwhen parameter exists, use port as proxy (must define proxy_host as well)\n\n\n\n\n\n\n\n\nAll script files and configurations are backed up in Looqbox's Cloud. To transfer all your work between your local machine and a server, all you need to do is rerun the docker command above. It will automatically download all files to the new instance.\n\n\nTo check if looqbox started correctly, run: \n\n\ndocker logs -f --tail 200 looqbox-instance\n\n\n\n\nExpected result:\n\n\n  \n\n\n\n\nTo update Looqbox and Looqbox's R package, pull the image's newest version and start a new container.\n\n\nFirst steps\n\n\nAfter completing this section you'll be able to run your first script inside Looqbox.\n\n\n\n\n\nLibraries\n\n\nIn order to develop a script for Looqbox you should use our Looqbox Package. The package allows you to interact with the interface and help you structure your data to be displayed in our client.\n\n\nlibrary(looqbox)\n\n\n\n\nLooq Response\n\n\nThis block is where your script will start the execution, simulating a main function. Inside it, you should use \nlooq.lookTag()\n  to receive the value inside a looqbox tag from parser\n\n\nIn this case, we are creating a looqbox standard message box and storing it in msg variable. In the first parameter we're passing a \npaste\n with the string collected above. The second parameter is the style type to display the box. \n\n\nFinally, we are creating a looqbox frame to be placed inside a board with \nlooq.responseFrame()\n\n\nlooq.response <- function(par) {\n\n  # Receives the value inside a looqbox tag. In this case, we're looking for \n  # $quotes tag and storing it in quotes\n  quotes <- looq.lookTag(\"$quotes\", par)\n\n  # Creates a looqbox standard message box and store it in msg variable. In\n  # the first parameter we're passing a paste with the string collected above\n  # the second parameter is the style type to display the box. \n  msg <- looq.objMessage(\n    paste(\"Hurray, my installation is working!!\\n\", quotes),\n    \"alert-success\"\n  )\n\n  # Creates a looqbox frame to be placed inside a board\n  looq.responseFrame(msg)\n}\n\n\n\n\nTesting\n\n\nThis block is used to test your response from \nRStudio\n, allowing you to simulate our parser and test your script without saving it in Looqbox client. If you have configured your Looqbox addin correctly, you can run your script using \nCtrl + Shift + S\n and it will be displayed in your client.\n\n\nlooq.testQuestion(\n  list(\n    \"$quotes\" = \"My test sentence\"\n  )\n)\n\n\n\n\nAdd to your client\n\n\n\n\n\nYou can find the complete script in our \nGithub\n or copy the code below. \n\n\n# In order to develop a script for Looqbox you should use our Looqbox Package.\n# The package allows you to interact with the interface and help you structure\n# your data to be displayed in our client.\nlibrary(looqbox)\n\n#-----------------------------------------------------------------------------#\n#---  Response\n#---\n#--- This block is where your script will start the execution, simulating a \n#--- main function. Inside it, you should set your parameters got from parser\n#-----------------------------------------------------------------------------#\nlooq.response <- function(par) {\n\n  # Receives the value inside a looqbox tag. In this case, we're looking for \n  # $quotes tag and storing it in quotes\n  quotes <- looq.lookTag(\"$quotes\", par)\n\n  # Creates a looqbox standard message box and store it in msg variable. In\n  # the first parameter we're passing a paste with the string collected above\n  # the second parameter is the style type to display the box. \n  msg <- looq.objMessage(\n    paste(\"Hurray, my installation is working!!\\n\", quotes),\n    \"alert-success\"\n  )\n\n  # Creates a looqbox frame to be placed inside a board\n  looq.responseFrame(msg)\n}\n\n#-----------------------------------------------------------------------------#\n#--- Test Block\n#\n#--- This block is used to test your response, allowing you to simulate our\n#--- parser and test your script without saving it in Looqbox client.\n#---\n#--- If you have configured your Looqbox addin correctly, you can run your \n#--- script using Ctrl + Shift + S and it will be displayed in your client.\n#-----------------------------------------------------------------------------#\nlooq.testQuestion(\n  list(\n    \"$quotes\" = \"My test sentence\"\n  )\n)\n\n\n\n\nAre you ready to learn more about Looqbox? Click \nhere\n to continue.",
            "title": "Home"
        },
        {
            "location": "/#home",
            "text": "",
            "title": "Home"
        },
        {
            "location": "/#introduction",
            "text": "",
            "title": "Introduction"
        },
        {
            "location": "/#installation",
            "text": "Looqbox must be installed in a Linux distribution that supports docker (e.g. Ubuntu 18.04 LTS).  To start the container, run:  docker run -d --restart=always --name=looqbox-instance -e CLIENT=\"<client name>\" -e KEY=\"<client key>\" -e RSTUDIO_PASS=\"<choose a password>\" -p 80:80 -p 8787:8787 looqboxrep/fes-public:cloud002",
            "title": "Installation"
        },
        {
            "location": "/#available-parameters",
            "text": "Parameter  Description      -e XMX=\"-Xmx512m\"  change maximum heap    -e XMS=\"-Xms512m\"  change minimum heap    -e PORT  change Looqbox's port (default 80)    -e PROXY_HOST=\"<ip>\"  when parameter exists, use host as proxy (must define proxy_port as well)    -e PROXY_PORT=\"<port>\"  when parameter exists, use port as proxy (must define proxy_host as well)     All script files and configurations are backed up in Looqbox's Cloud. To transfer all your work between your local machine and a server, all you need to do is rerun the docker command above. It will automatically download all files to the new instance.  To check if looqbox started correctly, run:   docker logs -f --tail 200 looqbox-instance  Expected result: \n     To update Looqbox and Looqbox's R package, pull the image's newest version and start a new container.",
            "title": "Available parameters"
        },
        {
            "location": "/#first-steps",
            "text": "After completing this section you'll be able to run your first script inside Looqbox.",
            "title": "First steps"
        },
        {
            "location": "/#libraries",
            "text": "In order to develop a script for Looqbox you should use our Looqbox Package. The package allows you to interact with the interface and help you structure your data to be displayed in our client.  library(looqbox)",
            "title": "Libraries"
        },
        {
            "location": "/#looq-response",
            "text": "This block is where your script will start the execution, simulating a main function. Inside it, you should use  looq.lookTag()   to receive the value inside a looqbox tag from parser  In this case, we are creating a looqbox standard message box and storing it in msg variable. In the first parameter we're passing a  paste  with the string collected above. The second parameter is the style type to display the box.   Finally, we are creating a looqbox frame to be placed inside a board with  looq.responseFrame()  looq.response <- function(par) {\n\n  # Receives the value inside a looqbox tag. In this case, we're looking for \n  # $quotes tag and storing it in quotes\n  quotes <- looq.lookTag(\"$quotes\", par)\n\n  # Creates a looqbox standard message box and store it in msg variable. In\n  # the first parameter we're passing a paste with the string collected above\n  # the second parameter is the style type to display the box. \n  msg <- looq.objMessage(\n    paste(\"Hurray, my installation is working!!\\n\", quotes),\n    \"alert-success\"\n  )\n\n  # Creates a looqbox frame to be placed inside a board\n  looq.responseFrame(msg)\n}",
            "title": "Looq Response"
        },
        {
            "location": "/#testing",
            "text": "This block is used to test your response from  RStudio , allowing you to simulate our parser and test your script without saving it in Looqbox client. If you have configured your Looqbox addin correctly, you can run your script using  Ctrl + Shift + S  and it will be displayed in your client.  looq.testQuestion(\n  list(\n    \"$quotes\" = \"My test sentence\"\n  )\n)",
            "title": "Testing"
        },
        {
            "location": "/#add-to-your-client",
            "text": "You can find the complete script in our  Github  or copy the code below.   # In order to develop a script for Looqbox you should use our Looqbox Package.\n# The package allows you to interact with the interface and help you structure\n# your data to be displayed in our client.\nlibrary(looqbox)\n\n#-----------------------------------------------------------------------------#\n#---  Response\n#---\n#--- This block is where your script will start the execution, simulating a \n#--- main function. Inside it, you should set your parameters got from parser\n#-----------------------------------------------------------------------------#\nlooq.response <- function(par) {\n\n  # Receives the value inside a looqbox tag. In this case, we're looking for \n  # $quotes tag and storing it in quotes\n  quotes <- looq.lookTag(\"$quotes\", par)\n\n  # Creates a looqbox standard message box and store it in msg variable. In\n  # the first parameter we're passing a paste with the string collected above\n  # the second parameter is the style type to display the box. \n  msg <- looq.objMessage(\n    paste(\"Hurray, my installation is working!!\\n\", quotes),\n    \"alert-success\"\n  )\n\n  # Creates a looqbox frame to be placed inside a board\n  looq.responseFrame(msg)\n}\n\n#-----------------------------------------------------------------------------#\n#--- Test Block\n#\n#--- This block is used to test your response, allowing you to simulate our\n#--- parser and test your script without saving it in Looqbox client.\n#---\n#--- If you have configured your Looqbox addin correctly, you can run your \n#--- script using Ctrl + Shift + S and it will be displayed in your client.\n#-----------------------------------------------------------------------------#\nlooq.testQuestion(\n  list(\n    \"$quotes\" = \"My test sentence\"\n  )\n)  Are you ready to learn more about Looqbox? Click  here  to continue.",
            "title": "Add to your client"
        },
        {
            "location": "/implementation/",
            "text": "Implementation\n\n\n\n\nImplementation Flow\n\n\nSetting up a connection\n\n\nCreating a response\n\n\nCreating User, UserGroup and ResponseGroup\n\n\nEntity By Code and Entity By Name\n\n\nReplacements\n\n\n\n\nImplementation Flow\n\n\nThere are 2 important concepts that you should know to understand our recommentation about how responses should be implemented in Looqbox.\n\n\n\n\n\n\nLooqbox runs a R script for each question asked by the users. Each of those scripts access a datasource (e.g. MySQL), so the time that a users waits is mainly the response time from the query or API. The maximum recommended time for a response is 2 seconds.\n\n\n\n\n\n\nUsers usually need a bit of experience with the interface to start asking more complex questions, so starting with short and general questions help new users to navigate.\n\n\n\n\n\n\nWe discorage the implementation of complex dashboards in Looqbox, since it usually depends of multiple queries, which result in a long response time.\n\n\nTo guarantee the best user experience, responses should be implemented in a way that users can ask simple questions, and navigate to more specific information using features like drill down. Navigating between 4 tables of content waiting 2 seconds for each load in much better than waiting 8 seconds for a single dashboard.\n\n\nHere is a sequence of questions to illustrate this scenario:\n\n\n\n\nsales $date\n\n\nsales $date by store\n\n\nsales $date by department\n\n\nsales $date by supplier\n\n\n\n\nSetting up a connection\n\n\nCreating a response\n\n\nCreating User\n\n\nCreating UserGroup\n\n\nCreating ResponseGroup\n\n\nEntity\n\n\nEntity By Code\n\n\nEntity By Name\n\n\nReplacements",
            "title": "Implementation"
        },
        {
            "location": "/implementation/#implementation",
            "text": "Implementation Flow  Setting up a connection  Creating a response  Creating User, UserGroup and ResponseGroup  Entity By Code and Entity By Name  Replacements",
            "title": "Implementation"
        },
        {
            "location": "/implementation/#implementation-flow",
            "text": "There are 2 important concepts that you should know to understand our recommentation about how responses should be implemented in Looqbox.    Looqbox runs a R script for each question asked by the users. Each of those scripts access a datasource (e.g. MySQL), so the time that a users waits is mainly the response time from the query or API. The maximum recommended time for a response is 2 seconds.    Users usually need a bit of experience with the interface to start asking more complex questions, so starting with short and general questions help new users to navigate.    We discorage the implementation of complex dashboards in Looqbox, since it usually depends of multiple queries, which result in a long response time.  To guarantee the best user experience, responses should be implemented in a way that users can ask simple questions, and navigate to more specific information using features like drill down. Navigating between 4 tables of content waiting 2 seconds for each load in much better than waiting 8 seconds for a single dashboard.  Here is a sequence of questions to illustrate this scenario:   sales $date  sales $date by store  sales $date by department  sales $date by supplier",
            "title": "Implementation Flow"
        },
        {
            "location": "/implementation/#setting-up-a-connection",
            "text": "",
            "title": "Setting up a connection"
        },
        {
            "location": "/implementation/#creating-a-response",
            "text": "",
            "title": "Creating a response"
        },
        {
            "location": "/implementation/#creating-user",
            "text": "",
            "title": "Creating User"
        },
        {
            "location": "/implementation/#creating-usergroup",
            "text": "",
            "title": "Creating UserGroup"
        },
        {
            "location": "/implementation/#creating-responsegroup",
            "text": "",
            "title": "Creating ResponseGroup"
        },
        {
            "location": "/implementation/#entity",
            "text": "",
            "title": "Entity"
        },
        {
            "location": "/implementation/#entity-by-code",
            "text": "",
            "title": "Entity By Code"
        },
        {
            "location": "/implementation/#entity-by-name",
            "text": "",
            "title": "Entity By Name"
        },
        {
            "location": "/implementation/#replacements",
            "text": "",
            "title": "Replacements"
        }
    ]
}