{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quickstart Looqbox is the data search solution for your business! Our recommendation is to implement, according to user feedback, all recurrent questions about KPIs from your business. Instead of executing the same database queries every week with different parameters to answer the same questions, just implement scripts once in Looqbox, and the users can ask as many times as they need. As the number of responses grows, your BI team will stop wasting time repeating work that can be automated in Looqbox. Your on-premise instance of Looqbox must connect to Looqbox's cloud. The cloud is used to control user access, register access groups and linguistic parameters, and (most important) understand the questions typed by users. All users and admins connect directly to the on-premise instance. Only on-premise instances communicate with the cloud. This architecture allows that a simple rule of access from within your company's network must be set (add the cloud DNS to a whitelist or allow access from a firewall), while users inside the company access the local instance. If you need to use a proxy, click here . It's important to remember that when generating a visualization for a user, your on-premise instance doesn't send the information retrieved from your Data Sources to Looqbox's cloud . Introduction In the sections below you'll be able to install Looqbox, login, ask your first questions and implement a response on your own! After this Quickstart, you can: Read more about the admin interface See common scenarios that you'll find throughout the implementation in the Cookbook Understand how to use Looqbox's R package in scripts Read about Looqbox's architecture and additional parameters when initializing Installation Looqbox must be installed in a Linux distribution that supports Docker (e.g. Ubuntu 18.04 LTS). You can use either Docker CE or Docker EE, although Docker CE is free to use and should be enough to run looqbox's instance. To see Docker's documentation about compatibility, click here . After installing Docker , start Looqbox's container: >Your KEY and CLIENT values are provided by looqbox and sent through e-mail. >RSTUDIO_PASS is a password you have to choose in order to access RStudio. docker run -d --restart=always --name=looqbox-instance -e CLIENT=\"<client-name>\" -e KEY=\"<client-key>\" -e RSTUDIO_PASS=\"<choose-a-password>\" -p 80:80 -p 8787:8787 looqboxrep/fes-public:cloud002 To check if Looqbox started correctly, run: docker logs -f --tail 200 looqbox-instance Expected result: Looqbox is now serving at port 80 and RStudio is serving at port 8787 (if it's a local instalation: localhost:80 ) Your Looqbox instance connects to our cloud (https://cloud002.looqbox.com or host in image above). If you need to add a proxy or change Looqbox's initialization port, click here . Update or transfer Looqbox to another server/computer All script files and configurations are backed up in Looqbox's Cloud. To transfer all your work between your local machine and a server or between servers, all you need to do is rerun the docker command above. It will automatically download all files to the new instance. If more than 1 instance is available, response scripts will sync in approx 45 seconds and all other information instantaneously. To update Looqbox and Looqbox's R package, pull the image's newest version and start a new container. For more help about docker commands to stop and update Looqbox, click here . First questions You can test your newly installed Looqbox by using pre-implemented responses (those responses also serve as models for the responses will you implement later!). To see the list of available questions/responses, type \"que perguntas posso fazer?\" (The first question asked after starting Looqbox takes about 8 seconds to respond. Learn more ) Your first response/script Follow the steps below to create your first Response/Script. Click the cogs in the right upper corner and then in Admin (don't mistake it with the user area if the user's name you're using is \"Admin\"!). Find Responses and click it. Press New + button. Fill the following fields and leave all others with the default values: Response Name: helloWorld Response Group: admin Language: pt-br Keyword: hello (press enter to open a new field) world (enter) script (enter) $quotes Example: hello world script \"this is my first script\" Press the green button Create new at the bottom. There will be a message \"file saved\" at the right upper corner. You just created your first Response! Now let's link it with a script. Find Response Files and press new in main file missing (new) . Press + show editor in grey located at the left of the save button. Copy the complete script in our Github or copy the code below, paste it and press save button. Click at Looqbox in the left upper corner to return to the search area, and type hello world script \"any message that you want\" . If the return was a green message box with the message Hurray, my installation is working! in the first line and the message you wrote in the second line, your installation is complete. # To develop a script for Looqbox you should use our Looqbox Package. # The package allows you to interact with the interface and help you structure # your data to be displayed in our client. library(looqbox) #-----------------------------------------------------------------------------# #--- Response #--- #--- This block is where your script will start the execution, simulating a #--- main function. Inside it, you should set your parameters got from parser #-----------------------------------------------------------------------------# looq.response <- function(par) { # Receives the value inside a looqbox tag. In this case, we're looking for # $quotes tag and storing it in quotes quotes <- looq.lookTag(\"$quotes\", par) # Creates a looqbox standard message box and store it in msg variable. In # the first parameter we're passing a paste with the string collected above # the second parameter is the style type to display the box. msg <- looq.objMessage( paste(\"Hurray, my installation is working!\\n\", quotes), \"alert-success\" ) # Creates a looqbox frame to be placed inside a board looq.responseFrame(msg) } #-----------------------------------------------------------------------------# #--- Test Block # #--- This block is used to test your response, allowing you to simulate our #--- parser and test your script without saving it in Looqbox client. #--- #--- If you have configured your Looqbox addin correctly, you can run your #--- script using Ctrl + Shift + S and it will be displayed in your client. #-----------------------------------------------------------------------------# looq.testQuestion( list( \"$quotes\" = \"My test sentence\" ) ) Are you ready to learn more about Looqbox? Click here to continue.","title":"Quickstart"},{"location":"#quickstart","text":"Looqbox is the data search solution for your business! Our recommendation is to implement, according to user feedback, all recurrent questions about KPIs from your business. Instead of executing the same database queries every week with different parameters to answer the same questions, just implement scripts once in Looqbox, and the users can ask as many times as they need. As the number of responses grows, your BI team will stop wasting time repeating work that can be automated in Looqbox. Your on-premise instance of Looqbox must connect to Looqbox's cloud. The cloud is used to control user access, register access groups and linguistic parameters, and (most important) understand the questions typed by users. All users and admins connect directly to the on-premise instance. Only on-premise instances communicate with the cloud. This architecture allows that a simple rule of access from within your company's network must be set (add the cloud DNS to a whitelist or allow access from a firewall), while users inside the company access the local instance. If you need to use a proxy, click here . It's important to remember that when generating a visualization for a user, your on-premise instance doesn't send the information retrieved from your Data Sources to Looqbox's cloud .","title":"Quickstart"},{"location":"#introduction","text":"In the sections below you'll be able to install Looqbox, login, ask your first questions and implement a response on your own! After this Quickstart, you can: Read more about the admin interface See common scenarios that you'll find throughout the implementation in the Cookbook Understand how to use Looqbox's R package in scripts Read about Looqbox's architecture and additional parameters when initializing","title":"Introduction"},{"location":"#installation","text":"Looqbox must be installed in a Linux distribution that supports Docker (e.g. Ubuntu 18.04 LTS). You can use either Docker CE or Docker EE, although Docker CE is free to use and should be enough to run looqbox's instance. To see Docker's documentation about compatibility, click here . After installing Docker , start Looqbox's container: >Your KEY and CLIENT values are provided by looqbox and sent through e-mail. >RSTUDIO_PASS is a password you have to choose in order to access RStudio. docker run -d --restart=always --name=looqbox-instance -e CLIENT=\"<client-name>\" -e KEY=\"<client-key>\" -e RSTUDIO_PASS=\"<choose-a-password>\" -p 80:80 -p 8787:8787 looqboxrep/fes-public:cloud002 To check if Looqbox started correctly, run: docker logs -f --tail 200 looqbox-instance Expected result: Looqbox is now serving at port 80 and RStudio is serving at port 8787 (if it's a local instalation: localhost:80 ) Your Looqbox instance connects to our cloud (https://cloud002.looqbox.com or host in image above). If you need to add a proxy or change Looqbox's initialization port, click here .","title":"Installation"},{"location":"#update-or-transfer-looqbox-to-another-servercomputer","text":"All script files and configurations are backed up in Looqbox's Cloud. To transfer all your work between your local machine and a server or between servers, all you need to do is rerun the docker command above. It will automatically download all files to the new instance. If more than 1 instance is available, response scripts will sync in approx 45 seconds and all other information instantaneously. To update Looqbox and Looqbox's R package, pull the image's newest version and start a new container. For more help about docker commands to stop and update Looqbox, click here .","title":"Update or transfer Looqbox to another server/computer"},{"location":"#first-questions","text":"You can test your newly installed Looqbox by using pre-implemented responses (those responses also serve as models for the responses will you implement later!). To see the list of available questions/responses, type \"que perguntas posso fazer?\" (The first question asked after starting Looqbox takes about 8 seconds to respond. Learn more )","title":"First questions"},{"location":"#your-first-responsescript","text":"Follow the steps below to create your first Response/Script. Click the cogs in the right upper corner and then in Admin (don't mistake it with the user area if the user's name you're using is \"Admin\"!). Find Responses and click it. Press New + button. Fill the following fields and leave all others with the default values: Response Name: helloWorld Response Group: admin Language: pt-br Keyword: hello (press enter to open a new field) world (enter) script (enter) $quotes Example: hello world script \"this is my first script\" Press the green button Create new at the bottom. There will be a message \"file saved\" at the right upper corner. You just created your first Response! Now let's link it with a script. Find Response Files and press new in main file missing (new) . Press + show editor in grey located at the left of the save button. Copy the complete script in our Github or copy the code below, paste it and press save button. Click at Looqbox in the left upper corner to return to the search area, and type hello world script \"any message that you want\" . If the return was a green message box with the message Hurray, my installation is working! in the first line and the message you wrote in the second line, your installation is complete. # To develop a script for Looqbox you should use our Looqbox Package. # The package allows you to interact with the interface and help you structure # your data to be displayed in our client. library(looqbox) #-----------------------------------------------------------------------------# #--- Response #--- #--- This block is where your script will start the execution, simulating a #--- main function. Inside it, you should set your parameters got from parser #-----------------------------------------------------------------------------# looq.response <- function(par) { # Receives the value inside a looqbox tag. In this case, we're looking for # $quotes tag and storing it in quotes quotes <- looq.lookTag(\"$quotes\", par) # Creates a looqbox standard message box and store it in msg variable. In # the first parameter we're passing a paste with the string collected above # the second parameter is the style type to display the box. msg <- looq.objMessage( paste(\"Hurray, my installation is working!\\n\", quotes), \"alert-success\" ) # Creates a looqbox frame to be placed inside a board looq.responseFrame(msg) } #-----------------------------------------------------------------------------# #--- Test Block # #--- This block is used to test your response, allowing you to simulate our #--- parser and test your script without saving it in Looqbox client. #--- #--- If you have configured your Looqbox addin correctly, you can run your #--- script using Ctrl + Shift + S and it will be displayed in your client. #-----------------------------------------------------------------------------# looq.testQuestion( list( \"$quotes\" = \"My test sentence\" ) )","title":"Your first response/script"},{"location":"#are-you-ready-to-learn-more-about-looqbox-click-here-to-continue","text":"","title":"Are you ready to learn more about Looqbox? Click here to continue."},{"location":"Admin-Interface/","text":"Admin Looqbox must be fast - Implementation Flow There are 2 important concepts that you should know to understand our recommentation about how responses should be implemented in Looqbox. Looqbox runs a R script for each question asked by the users. Each of those scripts access a datasource (e.g. MySQL), so the time that a users waits is mainly the response time from the query or API. The maximum recommended time for a response is 2 seconds. Users usually need a bit of experience with the interface to start asking more complex questions, so starting with short and general questions help new users to navigate. We discorage the implementation of complex dashboards in Looqbox, since it usually depends of multiple queries, which result in a long response time. To guarantee the best user experience, responses should be implemented in a way that users can ask simple questions, and navigate to more specific information using features like drill down. Navigating between 4 tables of content waiting 2 seconds for each load is much better than waiting 8 seconds for a single dashboard. Here is a sequence of questions to illustrate this scenario: sales $date sales $date by store sales $date by department sales $date by supplier Basics Following the instructions below will allow a admin to perform all kinds of tasks inside Looqbox. Many of the tasks are similar to other systems, such as creating users, connections to DBs and so on. There are 4 admin commands that can be used after a question in Looqbox's main screen to navigate quickly to the most important screens and to understand the main feature about Looqbox (NLP): $debug , $response , $script , $query (under construction - add gif) $debug This is your main command to visualize the parameters that Looqbox undestands from a question. If you are getting a unexpected behavior, or if the wrong script is being run when a specific question is asked, you can use $debug to see the response, the entities retrieved from the question and so on. (Please test the examples below. This command will be most useful in the Entities section ) venda ontem $debug top 10 produtos $debug meta ontem versus hj $debug venda do ano passado por mes $debug $response Sends the user to the response that Looqbox links to the script that would run with the given question. venda ontem $response $script Sends the user to the R script that Looqbox would run with the given question. venda ontem $script $query Shows all queries executed by the script. If the script breaks, this command returns all queries already executed. venda ontem $query Admin Interface Database Connection Creating a response Here you can link keywords to a script. We will divide this section in 3 parts. Basic info Response Name: use a name to find this response easily later Response Group: each response must belong to a response group, used to control who can access this resource Engine: R (default) is the only engine available for scripts Custom evaluation time limit: ATTENTION. Don't modify unless it's extremely necessary. This field is used to modify the default timeout (30s) for a script to respond. Good scripts run under 2 seconds, so there should be really no reason to modify this value Active: (self explanatory) Response files Response files: Use this area to upload scripts or help files. The main file will/must always have the same name as the responseName. IMPORTANT : .r extension MUST be lowercase Keyword Group Language: language that will use this keyword group Keyword: IMPORTANT . Here you can define which keywords must be present in a sentence to run this response. The script that will be executed will always be chosen by the highest number of entities found inside a question that in linked to a response. Keywords can be divided in 2 groups: simple words: usually stem or a verb in infitive. E.g. for a report about sales, use as keyword \"sales\", and all variations such as \"sell\", \"sold\", \"selling\" can be registered under Replacements . entities: starts with \"$\", and represent a pattern that can be found in the question. The most used entity is \"$date\", which is preimplemented by Looqbox. You can create your own entities (see EntityByCode and EntityByName ) A list of synonyms can be used by separating words with pipes. E.g.: sales|revenue Note that keywords can be optional. This is useful for entites that may appear in a question, but is not fundamental for the main usage case for a response. To illustrate: Imagine that it's important for a user to ask about sales \"sales yesterday\" (which returns a table with the sales in each store), but it's also common to modify the answer by asking \"sales yesterday store 1, 2 and 3\" (which returns a table with the sales of store 1, 2 and 3). In this case, the entity $store is optional, and when available, all values about store (in our example, 1 to 3) will be fowarded to the script within the entity $store. Creating User In this section you are able to create users that will have access to Looqbox. User Login: name used by the user to login. Short Name: alias for the user. Email: used when a user forgets the password. Password: (self explanatory) User Group: Each user must have a User Group . User groups are usually divided in roles inside a company (sales, marketing etc)l Language: default language for this user. Admin: select if a user can edit user, responses, entities and so on. Active: (self explanatory) Creating UserGroup User groups are usually divided in roles inside a company (sales, marketing etc). When creating users , you can define which userGroup this user belongs to. Response Groups: Define which Response Groups are linked to this user group. User Group Suggestions: Suggestions added will be shown to users that belong to this userGroup in the favorites and autocomplete. Creating ResponseGroup Each response belongs to a single responseGroup. When creating userGroups , you can choose multiple responseGroups that access is allowed to the userGroup. Response Group Name: define a name for a responseGroup. Entity Entities are patterns that can be found in the question, and retrieved as values to be used inside scripts. The most used entity is \"$date\", which is preimplemented by Looqbox. Other entities can be implemented as you need. E.g.: \"sales last week\" -> $date: [2018-09-10, 2018-09-16] To visualize the sections bellow, test the examples with the $debug command in Looqbox's interface. Default entities by Looqbox $date Looqbox interprets many different ways to refer to dates. Since it's the most used entity, it's always being improved by our team. Here are some examples from thousands of combinations of how a user can refer to a date in Looqbox: ontem, hoje (hj), amanh\u00e3 semana passada, mes passado, ano passado, d\u00e9cada passada semana que vem, mes que vem, ano que vem, d\u00e9cada que vem 1 de abril, 24 de dezembro setembro de 2018, janeiro do ano passado 1 de abril de 2018 28/01/1991, 02-02-2010 segunda feira, segunda feira da semana passada, segunda da semana que vem $datePartition Used to imply a way to split date value inside a script. Those references are: por dia, di\u00e1ria, dia a dia por semana, semanal, semana a semana por mes, mensal, mes a mes por bimestre, bimestral, bimestralmente, bimestre a bimestre (same as above for trimestre, quadrimestre, semestre) por ano, anual, ano a ano $comparative Comparative works by indicating a comparison between 2 $dates. For example: hj vs ontem mes passado versus retrasado ano semana passada versus semana atual $topN Used for ranking. $topn shows the number of elements that the user intents to select/work with. The maximum positive or negative number is 99,999. top 5 maiores 20 menores 15 top 8 maiores top 8 menores $email Used to return email found in question. contact@looqbox.com jobs@looqbox.com $quotes Anything between quotes is treated as plain text (no rules about entities will be applyed). It's commonly used to refer about product, store name and other text that must have a exact value. \"coca cola\" \"revista abril\" $diamond Similar to $quotes, any text between square brackets will be treated as exact value and will have no rules applyed over. [Looqbox] [350ml pkg 6units] Entity By Code Most used entity. With EntityByCode, you can define a pattern that, if preceded by a \"head\", will return a value to the R script. E.g.: $store entity head: lojas?|filial|filiais , entity pattern: \\d+ When \"venda na loja 20\" is asked, the R script will receive the entity $store with the value 20. Note that the pattern \\d+ is used to determine if what comes after [loja, lojas, filial, filiais] is a number, and Looqbox will already apply this pattern to a list of stores if necessary, reducing the complexity of patterns that needs to be implemented by you. E.g.: The same example above also works for \"venda na loja 20, 21 e 22\", which returns the values [20, 21, 22] to the R script. Another way to implement EntityByCode is by combining it with $diamond . The advantage of using $diamond with EntityByCode can be seem in 2 cases: A id is not available, and a exact text must be passed to a new question by a drill down, so it can be used to query information in the DB. $store entity head: lojas?|filial|filiais , entity pattern: <> When \"venda na loja [Fides]\" is asked, the R script will receive the entity $store with the value Fides . Now this string can be used to query this specific name in the DB. A id and a name for the entity are available, and you want to show the name of a pattern to the user, while using the id to query data in the DB. $store entity head: lojas?|filial|filiais , entity pattern: <> When \"venda na loja [Fides|20]\" is asked, the R script will receive the entity $store with the value 20. The advantage of this case is that the user sees a highlight with Fides , improving the readability of the question. A useful feature when adding a EntityByCode is to provide a CSV with all entries that you have in your data source, so when a user types a entity head, the entity autocomplete feature will start helping the user with all possible entries provided in the CSV. (under construction) Entity By Name EntityByName is useful when there is a small amount of entries that you want to link with a value (string or number) to be used in R scripts. This is recommended for a fast implementation when it's known that a user has no knowledge about the id of a entity and types the name of this entity. For cases with a long list of possibilities, we recommend implementing EntityByCode and upload a CSV with all entries, so the entity autocomplete feature can be used by the user asking the question. Here are some examples: $city, output: number prefix: cidade from: salinas, to: 1 from: belem, to: 2 When \"venda na cidade Belem\" is asked, the R script will receive the entity $city with the value 2. (under construction - example with output:string) Replacements","title":"Admin"},{"location":"Admin-Interface/#admin","text":"","title":"Admin"},{"location":"Admin-Interface/#looqbox-must-be-fast-implementation-flow","text":"There are 2 important concepts that you should know to understand our recommentation about how responses should be implemented in Looqbox. Looqbox runs a R script for each question asked by the users. Each of those scripts access a datasource (e.g. MySQL), so the time that a users waits is mainly the response time from the query or API. The maximum recommended time for a response is 2 seconds. Users usually need a bit of experience with the interface to start asking more complex questions, so starting with short and general questions help new users to navigate. We discorage the implementation of complex dashboards in Looqbox, since it usually depends of multiple queries, which result in a long response time. To guarantee the best user experience, responses should be implemented in a way that users can ask simple questions, and navigate to more specific information using features like drill down. Navigating between 4 tables of content waiting 2 seconds for each load is much better than waiting 8 seconds for a single dashboard. Here is a sequence of questions to illustrate this scenario: sales $date sales $date by store sales $date by department sales $date by supplier","title":"Looqbox must be fast - Implementation Flow"},{"location":"Admin-Interface/#basics","text":"Following the instructions below will allow a admin to perform all kinds of tasks inside Looqbox. Many of the tasks are similar to other systems, such as creating users, connections to DBs and so on. There are 4 admin commands that can be used after a question in Looqbox's main screen to navigate quickly to the most important screens and to understand the main feature about Looqbox (NLP): $debug , $response , $script , $query (under construction - add gif)","title":"Basics"},{"location":"Admin-Interface/#debug","text":"This is your main command to visualize the parameters that Looqbox undestands from a question. If you are getting a unexpected behavior, or if the wrong script is being run when a specific question is asked, you can use $debug to see the response, the entities retrieved from the question and so on. (Please test the examples below. This command will be most useful in the Entities section ) venda ontem $debug top 10 produtos $debug meta ontem versus hj $debug venda do ano passado por mes $debug","title":"$debug"},{"location":"Admin-Interface/#response","text":"Sends the user to the response that Looqbox links to the script that would run with the given question. venda ontem $response","title":"$response"},{"location":"Admin-Interface/#script","text":"Sends the user to the R script that Looqbox would run with the given question. venda ontem $script","title":"$script"},{"location":"Admin-Interface/#query","text":"Shows all queries executed by the script. If the script breaks, this command returns all queries already executed. venda ontem $query","title":"$query"},{"location":"Admin-Interface/#admin-interface","text":"","title":"Admin Interface"},{"location":"Admin-Interface/#database-connection","text":"","title":"Database Connection"},{"location":"Admin-Interface/#creating-a-response","text":"Here you can link keywords to a script. We will divide this section in 3 parts.","title":"Creating a response"},{"location":"Admin-Interface/#basic-info","text":"Response Name: use a name to find this response easily later Response Group: each response must belong to a response group, used to control who can access this resource Engine: R (default) is the only engine available for scripts Custom evaluation time limit: ATTENTION. Don't modify unless it's extremely necessary. This field is used to modify the default timeout (30s) for a script to respond. Good scripts run under 2 seconds, so there should be really no reason to modify this value Active: (self explanatory)","title":"Basic info"},{"location":"Admin-Interface/#response-files","text":"Response files: Use this area to upload scripts or help files. The main file will/must always have the same name as the responseName. IMPORTANT : .r extension MUST be lowercase","title":"Response files"},{"location":"Admin-Interface/#keyword-group","text":"Language: language that will use this keyword group Keyword: IMPORTANT . Here you can define which keywords must be present in a sentence to run this response. The script that will be executed will always be chosen by the highest number of entities found inside a question that in linked to a response. Keywords can be divided in 2 groups: simple words: usually stem or a verb in infitive. E.g. for a report about sales, use as keyword \"sales\", and all variations such as \"sell\", \"sold\", \"selling\" can be registered under Replacements . entities: starts with \"$\", and represent a pattern that can be found in the question. The most used entity is \"$date\", which is preimplemented by Looqbox. You can create your own entities (see EntityByCode and EntityByName ) A list of synonyms can be used by separating words with pipes. E.g.: sales|revenue Note that keywords can be optional. This is useful for entites that may appear in a question, but is not fundamental for the main usage case for a response. To illustrate: Imagine that it's important for a user to ask about sales \"sales yesterday\" (which returns a table with the sales in each store), but it's also common to modify the answer by asking \"sales yesterday store 1, 2 and 3\" (which returns a table with the sales of store 1, 2 and 3). In this case, the entity $store is optional, and when available, all values about store (in our example, 1 to 3) will be fowarded to the script within the entity $store.","title":"Keyword Group"},{"location":"Admin-Interface/#creating-user","text":"In this section you are able to create users that will have access to Looqbox. User Login: name used by the user to login. Short Name: alias for the user. Email: used when a user forgets the password. Password: (self explanatory) User Group: Each user must have a User Group . User groups are usually divided in roles inside a company (sales, marketing etc)l Language: default language for this user. Admin: select if a user can edit user, responses, entities and so on. Active: (self explanatory)","title":"Creating User"},{"location":"Admin-Interface/#creating-usergroup","text":"User groups are usually divided in roles inside a company (sales, marketing etc). When creating users , you can define which userGroup this user belongs to. Response Groups: Define which Response Groups are linked to this user group. User Group Suggestions: Suggestions added will be shown to users that belong to this userGroup in the favorites and autocomplete.","title":"Creating UserGroup"},{"location":"Admin-Interface/#creating-responsegroup","text":"Each response belongs to a single responseGroup. When creating userGroups , you can choose multiple responseGroups that access is allowed to the userGroup. Response Group Name: define a name for a responseGroup.","title":"Creating ResponseGroup"},{"location":"Admin-Interface/#entity","text":"Entities are patterns that can be found in the question, and retrieved as values to be used inside scripts. The most used entity is \"$date\", which is preimplemented by Looqbox. Other entities can be implemented as you need. E.g.: \"sales last week\" -> $date: [2018-09-10, 2018-09-16] To visualize the sections bellow, test the examples with the $debug command in Looqbox's interface.","title":"Entity"},{"location":"Admin-Interface/#default-entities-by-looqbox","text":"","title":"Default entities by Looqbox"},{"location":"Admin-Interface/#date","text":"Looqbox interprets many different ways to refer to dates. Since it's the most used entity, it's always being improved by our team. Here are some examples from thousands of combinations of how a user can refer to a date in Looqbox: ontem, hoje (hj), amanh\u00e3 semana passada, mes passado, ano passado, d\u00e9cada passada semana que vem, mes que vem, ano que vem, d\u00e9cada que vem 1 de abril, 24 de dezembro setembro de 2018, janeiro do ano passado 1 de abril de 2018 28/01/1991, 02-02-2010 segunda feira, segunda feira da semana passada, segunda da semana que vem","title":"$date"},{"location":"Admin-Interface/#datepartition","text":"Used to imply a way to split date value inside a script. Those references are: por dia, di\u00e1ria, dia a dia por semana, semanal, semana a semana por mes, mensal, mes a mes por bimestre, bimestral, bimestralmente, bimestre a bimestre (same as above for trimestre, quadrimestre, semestre) por ano, anual, ano a ano","title":"$datePartition"},{"location":"Admin-Interface/#comparative","text":"Comparative works by indicating a comparison between 2 $dates. For example: hj vs ontem mes passado versus retrasado ano semana passada versus semana atual","title":"$comparative"},{"location":"Admin-Interface/#topn","text":"Used for ranking. $topn shows the number of elements that the user intents to select/work with. The maximum positive or negative number is 99,999. top 5 maiores 20 menores 15 top 8 maiores top 8 menores","title":"$topN"},{"location":"Admin-Interface/#email","text":"Used to return email found in question. contact@looqbox.com jobs@looqbox.com","title":"$email"},{"location":"Admin-Interface/#quotes","text":"Anything between quotes is treated as plain text (no rules about entities will be applyed). It's commonly used to refer about product, store name and other text that must have a exact value. \"coca cola\" \"revista abril\"","title":"$quotes"},{"location":"Admin-Interface/#diamond","text":"Similar to $quotes, any text between square brackets will be treated as exact value and will have no rules applyed over. [Looqbox] [350ml pkg 6units]","title":"$diamond"},{"location":"Admin-Interface/#entity-by-code","text":"Most used entity. With EntityByCode, you can define a pattern that, if preceded by a \"head\", will return a value to the R script. E.g.: $store entity head: lojas?|filial|filiais , entity pattern: \\d+ When \"venda na loja 20\" is asked, the R script will receive the entity $store with the value 20. Note that the pattern \\d+ is used to determine if what comes after [loja, lojas, filial, filiais] is a number, and Looqbox will already apply this pattern to a list of stores if necessary, reducing the complexity of patterns that needs to be implemented by you. E.g.: The same example above also works for \"venda na loja 20, 21 e 22\", which returns the values [20, 21, 22] to the R script. Another way to implement EntityByCode is by combining it with $diamond . The advantage of using $diamond with EntityByCode can be seem in 2 cases: A id is not available, and a exact text must be passed to a new question by a drill down, so it can be used to query information in the DB. $store entity head: lojas?|filial|filiais , entity pattern: <> When \"venda na loja [Fides]\" is asked, the R script will receive the entity $store with the value Fides . Now this string can be used to query this specific name in the DB. A id and a name for the entity are available, and you want to show the name of a pattern to the user, while using the id to query data in the DB. $store entity head: lojas?|filial|filiais , entity pattern: <> When \"venda na loja [Fides|20]\" is asked, the R script will receive the entity $store with the value 20. The advantage of this case is that the user sees a highlight with Fides , improving the readability of the question. A useful feature when adding a EntityByCode is to provide a CSV with all entries that you have in your data source, so when a user types a entity head, the entity autocomplete feature will start helping the user with all possible entries provided in the CSV. (under construction)","title":"Entity By Code"},{"location":"Admin-Interface/#entity-by-name","text":"EntityByName is useful when there is a small amount of entries that you want to link with a value (string or number) to be used in R scripts. This is recommended for a fast implementation when it's known that a user has no knowledge about the id of a entity and types the name of this entity. For cases with a long list of possibilities, we recommend implementing EntityByCode and upload a CSV with all entries, so the entity autocomplete feature can be used by the user asking the question. Here are some examples: $city, output: number prefix: cidade from: salinas, to: 1 from: belem, to: 2 When \"venda na cidade Belem\" is asked, the R script will receive the entity $city with the value 2. (under construction - example with output:string)","title":"Entity By Name"},{"location":"Admin-Interface/#replacements","text":"","title":"Replacements"},{"location":"Cookbook/","text":"Cookbook This section provides well known use scenarios for Looqbox, and how to implement them. Each section below has a scenario and a solution . We recommend you to read all scenarios, and if any of them apply to you, follow the related instructions. Example 1 - Implementing a response with access to a database Scenario In this section you can see how to implement the main type of response in Looqbox! Questions such as \"venda ontem\" are the most fundamental for users. They are usually composed by a simple keyword + a entity (in this case $date). We are going to see how to implement a response with a query to a DB, and a filter based on date. Solution Step 1: Add a connection to a database Add a database connection if you don't have one already. To see the basics about adding a connection, click here . Your connection screen should be similar to the image below: It's important to notice that the connection's name that you chose will be used in the R script. Step 2: Create a response You can see the basics about creating a response here . Go to Admin > Responses and fill the fields just like in the image below: Hit Create New at the bottom. Now you have a response that will be executed whenever a user types \"venda\" and any variation of a date. \"venda ontem\", \"venda hj\", \"venda na segunda quinzena de abril de 2017\". Step 3: Add a script library(\"looqbox\") #-----------------------------------------------------------------------------# #---- get.data #-----------------------------------------------------------------------------# # get.data is one of the 3 main functions when creating a script. It's a logical # division in the script to gether information from a data source. # In this case, it's receiving a dateInt (date interval) and a storeList get.data <- function(dateInt,storeList) { # The query below will run against the database, and can accept filters in 2 forms. # 1 - Numbers between back ticks (``): for mandatory filters, use `1` and `2` and # so on as placeholders. Those placeholders will be replaced by values passed # during the looq.sqlExecute # 2 - looq.sqlIn function: for optional variables, you can use this funcion. # looq.sqlIn accepts 2 arguments. The first one is a segment of the query, and # the second in a variable. If the variable (in this case storeList) is NULL, # the funcion returns a empty string, not affecting in any way the query. If the # variable has a value, the second argument will be pasted (between brackets) along # with the first argument in the query. ##### ##### IMPORTANT: change the query so that it matches you database! ##### sql <- paste( \" SELECT c.STORE_NAME as Loja ,sum(s.SALES_VALUE) as Venda FROM looqdata.data_store_sales as s inner join looqdata.data_store_cad as c using(STORE_CODE) where 1=1 and date(s.DATE) between date(`1`) and date(`2`) \", looq.sqlIn(\"and s.STORE_CODE in \",storeList),\" group by c.STORE_NAME order by 1\" ) # looq.sqlExecute receives 3 arguments. # 1 - A connection name, created in Looqbox's interface in Admin > Connections # 2 - A query, like the \"sql\" variable created above # 3 - A list of parameters that will replace the placeholder (`1`, `2` ...) in the given order # # The query run, and the result is a objTable (a object that can be already # displayed in Looqbox's interface). This table is stored in the atribute $date # of the given variable (in this case, r$data) ##### ##### IMPORTANT: Remember to use the name of the connection that you set up in step 1! ##### r <- looq.sqlExecute(\"looqdata\", sql, list(dateInt[1],dateInt[2])) # If a table returns with empty content, the code stops here and a message is returned to the user # This section prevents the script to attempt to manipulate data of a empty table if(r$rows == 0) return(paste(\"Sem dados no per\u00edodo de:\\n\", dateInt[1], \"a\", dateInt[2])) # Rename columns, so it's easier to work with the table throughout the code names(r$data) <- c(\"Loja\", \"Venda\") # This attribute creates a footer for the table, with a hardcoded value, and a calculated value r$total <- list(\"Total\",sum(r$data$Venda)) # $title creates a title above the table when the table is presented in # the interface. It can receive a string or a vector of strings (which will be stacked) r$title <- c(\"Vendas\", # looq.titleForList verifies if there is a storeList. If # there is, executes a paste0() to create a segment of the title looq.titleForList(\"Loja: \", storeList), # looq.titleWithDate() formats the date received to show in the title above the table looq.titleWithDate(\"Per\u00edodo\", dateInt) ) # $valueFormat receives a named list (\"column\"=\"format\",\"column2\"=\"format2\") to format the columns. # The available formats are: \"number:n\", \"percent:n\", \"date\" e \"dateTime\" # \"n\" is the number of decimals r$valueFormat <- list( \"Venda\" = \"number:0\" ) # The same as above, but for the total line r$totalValueFormat <- list( \"Venda\" = \"number:0\" ) # $paginationSize controls the default amount of lines in a table before pagination. # It's a important feature when bigger tables should be shown in the interface r$paginationSize <- 15 # looq.responseFrame() displays in the interface the objects in the order that they are inputed. # In this case, it's only the objTable (r) looq.responseFrame(r) } #-----------------------------------------------------------------------------# #--- Response #-----------------------------------------------------------------------------# # Looqbox's main function. This function is called by the system when a script is executed. # All scripts must have this funcion implemented. # All parameters comprehended by Looqbox's Cloud are passed in the argument \"par\". looq.response <- function(par){ # looq.lookTag() retrieves entities found in the user's question. # If a entity is not found, NULL is returned. It's possible to define a default # value when a entity is not found. In the example below, this feature is used # with the entity $date (used today's date if none is found in the user's question) stores <- looq.lookTag(\"$store\", par) date <- looq.lookTag(\"$date\", par, list(c(Sys.Date(), Sys.Date()))) # looq.map() maps the value of the entities to get.data looq.map(get.data, date, list(stores)) } #-----------------------------------------------------------------------------# #--- Test Block #-----------------------------------------------------------------------------# # This block is used to test scripts in RStudio or in Admin > Test Scripts # Here you can define hardcoded values to simulate the entities found in a question # and simulate the behavior of your script looq.testQuestion( list( \"$date\"=list(c('2014-02-01','2014-02-28')) ,\"$store\"=c() ) ) Step 4: Test Click at \"Looqbox\" in the upper left corner, and type \"venda na semana passada\". You should see a response similar the one below: you can also type $debug after your question to see how dates are being Example 2 - Retrieving patterns from questions Scenario For questions such as: \"venda na loja Fides\". We would expect \"Fides\" do be retrieved as a value for the $store entity. But how should that entity be registered? Solution 1 - Entity By Code ($store) One good option is to register $store as a string-type entity, unsing diamonds( <> ) as the pattern and lojas? as the entity head. As you can see below: Solution 2 - Entity By Code ($store + autocomplete) Another option, and perhaps the most stylish, is to register $store as either a string- or digit-based entity by code and add an autocomplete .csv file. This will enable looqbox to suggest the entity in real time as you type in your search. The .csv should have one of the formats shown below: #For digit-based code-value entities code;value 0;example 1;Store 2;Fides 3;test #For string-based value only entities value example Store Fides test","title":"Cookbook"},{"location":"Cookbook/#cookbook","text":"This section provides well known use scenarios for Looqbox, and how to implement them. Each section below has a scenario and a solution . We recommend you to read all scenarios, and if any of them apply to you, follow the related instructions.","title":"Cookbook"},{"location":"Cookbook/#example-1-implementing-a-response-with-access-to-a-database","text":"","title":"Example 1 - Implementing a response with access to a database"},{"location":"Cookbook/#scenario","text":"In this section you can see how to implement the main type of response in Looqbox! Questions such as \"venda ontem\" are the most fundamental for users. They are usually composed by a simple keyword + a entity (in this case $date). We are going to see how to implement a response with a query to a DB, and a filter based on date.","title":"Scenario"},{"location":"Cookbook/#solution","text":"","title":"Solution"},{"location":"Cookbook/#step-1-add-a-connection-to-a-database","text":"Add a database connection if you don't have one already. To see the basics about adding a connection, click here . Your connection screen should be similar to the image below: It's important to notice that the connection's name that you chose will be used in the R script.","title":"Step 1: Add a connection to a database"},{"location":"Cookbook/#step-2-create-a-response","text":"You can see the basics about creating a response here . Go to Admin > Responses and fill the fields just like in the image below: Hit Create New at the bottom. Now you have a response that will be executed whenever a user types \"venda\" and any variation of a date. \"venda ontem\", \"venda hj\", \"venda na segunda quinzena de abril de 2017\".","title":"Step 2: Create a response"},{"location":"Cookbook/#step-3-add-a-script","text":"library(\"looqbox\") #-----------------------------------------------------------------------------# #---- get.data #-----------------------------------------------------------------------------# # get.data is one of the 3 main functions when creating a script. It's a logical # division in the script to gether information from a data source. # In this case, it's receiving a dateInt (date interval) and a storeList get.data <- function(dateInt,storeList) { # The query below will run against the database, and can accept filters in 2 forms. # 1 - Numbers between back ticks (``): for mandatory filters, use `1` and `2` and # so on as placeholders. Those placeholders will be replaced by values passed # during the looq.sqlExecute # 2 - looq.sqlIn function: for optional variables, you can use this funcion. # looq.sqlIn accepts 2 arguments. The first one is a segment of the query, and # the second in a variable. If the variable (in this case storeList) is NULL, # the funcion returns a empty string, not affecting in any way the query. If the # variable has a value, the second argument will be pasted (between brackets) along # with the first argument in the query. ##### ##### IMPORTANT: change the query so that it matches you database! ##### sql <- paste( \" SELECT c.STORE_NAME as Loja ,sum(s.SALES_VALUE) as Venda FROM looqdata.data_store_sales as s inner join looqdata.data_store_cad as c using(STORE_CODE) where 1=1 and date(s.DATE) between date(`1`) and date(`2`) \", looq.sqlIn(\"and s.STORE_CODE in \",storeList),\" group by c.STORE_NAME order by 1\" ) # looq.sqlExecute receives 3 arguments. # 1 - A connection name, created in Looqbox's interface in Admin > Connections # 2 - A query, like the \"sql\" variable created above # 3 - A list of parameters that will replace the placeholder (`1`, `2` ...) in the given order # # The query run, and the result is a objTable (a object that can be already # displayed in Looqbox's interface). This table is stored in the atribute $date # of the given variable (in this case, r$data) ##### ##### IMPORTANT: Remember to use the name of the connection that you set up in step 1! ##### r <- looq.sqlExecute(\"looqdata\", sql, list(dateInt[1],dateInt[2])) # If a table returns with empty content, the code stops here and a message is returned to the user # This section prevents the script to attempt to manipulate data of a empty table if(r$rows == 0) return(paste(\"Sem dados no per\u00edodo de:\\n\", dateInt[1], \"a\", dateInt[2])) # Rename columns, so it's easier to work with the table throughout the code names(r$data) <- c(\"Loja\", \"Venda\") # This attribute creates a footer for the table, with a hardcoded value, and a calculated value r$total <- list(\"Total\",sum(r$data$Venda)) # $title creates a title above the table when the table is presented in # the interface. It can receive a string or a vector of strings (which will be stacked) r$title <- c(\"Vendas\", # looq.titleForList verifies if there is a storeList. If # there is, executes a paste0() to create a segment of the title looq.titleForList(\"Loja: \", storeList), # looq.titleWithDate() formats the date received to show in the title above the table looq.titleWithDate(\"Per\u00edodo\", dateInt) ) # $valueFormat receives a named list (\"column\"=\"format\",\"column2\"=\"format2\") to format the columns. # The available formats are: \"number:n\", \"percent:n\", \"date\" e \"dateTime\" # \"n\" is the number of decimals r$valueFormat <- list( \"Venda\" = \"number:0\" ) # The same as above, but for the total line r$totalValueFormat <- list( \"Venda\" = \"number:0\" ) # $paginationSize controls the default amount of lines in a table before pagination. # It's a important feature when bigger tables should be shown in the interface r$paginationSize <- 15 # looq.responseFrame() displays in the interface the objects in the order that they are inputed. # In this case, it's only the objTable (r) looq.responseFrame(r) } #-----------------------------------------------------------------------------# #--- Response #-----------------------------------------------------------------------------# # Looqbox's main function. This function is called by the system when a script is executed. # All scripts must have this funcion implemented. # All parameters comprehended by Looqbox's Cloud are passed in the argument \"par\". looq.response <- function(par){ # looq.lookTag() retrieves entities found in the user's question. # If a entity is not found, NULL is returned. It's possible to define a default # value when a entity is not found. In the example below, this feature is used # with the entity $date (used today's date if none is found in the user's question) stores <- looq.lookTag(\"$store\", par) date <- looq.lookTag(\"$date\", par, list(c(Sys.Date(), Sys.Date()))) # looq.map() maps the value of the entities to get.data looq.map(get.data, date, list(stores)) } #-----------------------------------------------------------------------------# #--- Test Block #-----------------------------------------------------------------------------# # This block is used to test scripts in RStudio or in Admin > Test Scripts # Here you can define hardcoded values to simulate the entities found in a question # and simulate the behavior of your script looq.testQuestion( list( \"$date\"=list(c('2014-02-01','2014-02-28')) ,\"$store\"=c() ) )","title":"Step 3: Add a script"},{"location":"Cookbook/#step-4-test","text":"Click at \"Looqbox\" in the upper left corner, and type \"venda na semana passada\". You should see a response similar the one below: you can also type $debug after your question to see how dates are being","title":"Step 4: Test"},{"location":"Cookbook/#example-2-retrieving-patterns-from-questions","text":"","title":"Example 2 - Retrieving patterns from questions"},{"location":"Cookbook/#scenario_1","text":"For questions such as: \"venda na loja Fides\". We would expect \"Fides\" do be retrieved as a value for the $store entity. But how should that entity be registered?","title":"Scenario"},{"location":"Cookbook/#solution-1-entity-by-code-store","text":"One good option is to register $store as a string-type entity, unsing diamonds( <> ) as the pattern and lojas? as the entity head. As you can see below:","title":"Solution 1 - Entity By Code ($store)"},{"location":"Cookbook/#solution-2-entity-by-code-store-autocomplete","text":"Another option, and perhaps the most stylish, is to register $store as either a string- or digit-based entity by code and add an autocomplete .csv file. This will enable looqbox to suggest the entity in real time as you type in your search. The .csv should have one of the formats shown below: #For digit-based code-value entities code;value 0;example 1;Store 2;Fides 3;test #For string-based value only entities value example Store Fides test","title":"Solution 2 - Entity By Code ($store + autocomplete)"},{"location":"R-Scripts/","text":"R Scripts This tutorial assumes you don't have any previous knowledge in the Looqbox Package. Setup for the Tutorial This documentation's objective is to introduce you to the guidelines for creating organized and efficient R scripts for Looqbox as well as to make you confortable with the looqbox package and with the tool's environment and workflow. In this section we will focus on the creation and editing of the R scripts, so we recomend using Rstudio as the development environment. You can either write the code in your RStudio Serve, or you can set up a local development environment on your computer and use your local RStudio. Using Looqbox Dev Docker Container This option is a docker running with a local RStudio linked with your Looqbox-dev folder. First of all you need to install Docker in your local machine. More in docker official site . After installing docker you need to have a looqbox-dev folder in your machine. With the docker and the looqbox-dev folder installed you only need to execute these commands: - docker pull looqboxrep/looqbox-dev to pull the image, use the default looqbox login to pull. - docker run -d --restart=always -v $HOME/looqbox-dev/config:/home/rstudio/looqbox -p 8787:8787 looqboxrep/looqbox-dev . This command will set a local RStudio at port 8787 and will link to your config folder files in the -v command. To open your local RStudio you only have to access localhost:8787 in your browser! RStudio Serve Setup This is the quickest way to get started! Open your looqbox instance on port 8787 (usually: http://localhost:8787 ), enter rstudio as username and the password you created in the installation and you're almost ready to go. Under addins, select Looqbox and enter your looqbox username and host (if they're not already there). It is also recomended to have Looqbox opened on another tab, as your tests will be published there. You now have everything you need to begin, go ahead to the basics section . Basics Script sctructure In this section, you'll learn about the structure in which your script should be implemented. Dependencies In order to develop a script for Looqbox you should use our Looqbox Package as it allows you to interact with the interface and helps you structure your data to be displayed in our environment. library(\"looqbox\") get_data This user defined functions is the core of the script, we keep in it all of the data retrieval and manipulation. In it we also receive as parameters the entities collected from the parser and create the objects and vizualizations which will become our response. This function exists to keep the next block (looq.response) as clean and lean as possible. get_data <- function(dateInt, parameter, value){ sql <- \" SELECT EXAMPLE AS Col1, TEST AS Col2, FIELD AS Col3, DATE AS Date FROM example.table WHERE 1=1 AND Date >= DATE_ADD(`1`, INTERVAL +3 HOUR) AND Date < DATE_ADD(`2`, INTERVAL +3 HOUR) AND PARAMETER = `3` AND VALUE = `4` ORDER BY DATE DESC\" r <- looq.sqlExecute(\"myDB\", sql, list(dateInt[1], dateInt[2], parameter, value)) if(r$rows == 0) return(paste(\"No data found from:\\n\", dateInt[1], \"to\", dateInt[2])) r$total <- list( \"Col1\" = \"Total\", \"Col2\" = sum(r$data$Col2) ) r$searcheable <- T r$paginationSize <- 25 r } Above we have a good example of a generic get_data function, it receives some parameters, executes a query that uses them and creates a Looqbox table with a total line, searchbar and pagination. In this case the return is simply r (the looq.objectTable ) because we assume looq.map will be used to call get_data in the looq.response block. Don't worry if you still can't understand what each of these functions do, we have a section dedicated entirely to their study. looq.response This block is where your script's execution will start, it's a S3 object and resembles the common main function. Inside it, you should use looq.lookTag() to receive the value inside a looqbox tag from the parser. In this sample, we are creating a looqbox standard message box and storing it in the msg variable. In the first parameter we paste a string and the quotes entity's value, which was received from the parser. The second parameter message's style type(we will present the options later. Finally, we are creating a looqbox frame with looq.responseFrame() , and so, creating a Looqbox intelligible board. looq.response <- function(par) { # Receives the value inside a looqbox tag. In this case, we're looking for # $quotes tag and storing it in quotes quotes <- looq.lookTag(\"$quotes\", par) # Creates a looqbox standard message box and stores it in msg variable. In # the first parameter we're passing a paste with the string collected above # the second parameter is the style type to display the box. msg <- looq.objMessage( paste(\"Hurray, my installation is working!!\\n\", quotes), \"alert-success\" ) # Creates a looqbox frame to be placed inside a board looq.responseFrame(msg) } Test Block This block is a S3 object and is used to test your response from RStudio , allowing you to simulate our parser and test your script without saving it in Looqbox client. If you have configured your Looqbox addin correctly, you can run your script using Ctrl + Shift + S and it will be published to your client. In this block you should assign test values to any entities that your script calls for. looq.testQuestion( list( \"$quotes\" = \"My test sentence\" ) ) Essential functions Now that you have a general understanding of how a script is properly constructed, let us go over a few of the package's most important functions. NOTE: In this material we'll be working with practical examples. If you wish to understand the full depth and parameters of each of these functions please refer to the package documentation. looq.lookTag Normally, the first thing your code will do once it enters your looq.response() (main) function, is receive information from the parser (in JSON format). From this, we have to extract information such as entities and tags, which will be used as parameters in get_data() . looq.lookTag() acomplishes this task, searching for specific tags and returning their values. company <- looq.lookTag(\"$company\", par) In the example above, looq.lookTag takes two parameters: \"$company\" : The entity or pattern it will search for. par : the parser string, as received by looq.response(par) It will then, return the company value and assign it to the variable company . If a certain value is an optional parameter for a question, looq.lookTag() also accepts a third parameter for setting a default value (should be a list). date <- looq.lookTag(\"$date\", par, list(c('2018-01-01', '2019-01-01'))) In the code above, if no $date value is recognised by the parser it will choose the default, in this case, the period starting yesterday and ending today (whenever that is). looq.map This function is, perhaps, the core of the whole script. looq.map(get_data, date, company) What it does is fairly simple, the first argument is your get_data() function, and the remaining are variables defined by looq.lookTag() . looq.map() calls the function and passes the variables as arguments to it. Additionally, it wraps everything in a Looqbox response frame making get_data 's output intelligible by the interface. looq.sqlExecute Now that we've got looq.response covered, we'll go inside get_data . Think of it as the backstage of your script, it's where everything is prepared so that your main function keeps neat. Most of our scripts involve some kind of query to a database, looq.sqlExecute() is a funtion that makes this interaction extremely simple. # We generally store looq.sqlExecute's output in a variable called r r <- looq.sqlExecute(\"mySQLDev\", sql, list(dateInt[1], dateInt[2], company, value)) # A simple error test follows the query, checking for data absence if(r$rows == 0) return(paste(\"No data found from:\\n\", dateInt[1], \"to\", dateInt[2])) Normally it will take three arguments: \"mySQLDB\" : the database's name, as it was registered in the interface under connections. sql : a string containing the SQL query (we'll cover it in depth) ... : a list of parameters that will be inserted into the query. In a simple manner, looq.sqlExecute does exatly what the name implies, it executes your query within the database, but more than that, it lets you insert values in the query. Take the following example string: sql <- \" SELECT EXAMPLE, TEST, FIELD, DATE FROM example.table WHERE 1=1 AND DATE >= DATE_ADD(`1`, INTERVAL +3 HOUR) AND DATE < DATE_ADD(`2`, INTERVAL +3 HOUR) AND COMPANY = `3` AND VALUE = `4` ORDER BY DATE DESC \" The values between backticks ( ` ` ) are recognised by the function and substituted with the variables passed in the third argument of looq.SQLExecute , in order of appearance. Say that: company <- 0 dateInt <- c('2018-07-09', '2018-08-09') value <- 1120 The query sent to the database would be: SELECT EXAMPLE, TEST, FIELD, DATE FROM my.exampleDB WHERE 1=1 AND DATE >= DATE_ADD('2018-07-09', INTERVAL +3 HOUR) AND DATE < DATE_ADD('2018-08-09', INTERVAL +3 HOUR) AND COMPANY = 0 AND VALUE = 1120 ORDER BY DATE DESC Easy right? And it gets better, looq.sqlExecute returns a looq.objTable , an object from the package that is ready to be imported to the interface. looq.objTable and it's parameters The most common answer to Looqbox questions comes in the form of tables, but rather than using comon objects as data.frame or tbl we have developed a special object, which is recognised by the interface and will help you create bespoke tables, as it has a number of built-in customization options. Well go through it's most important parameters here, more advanced options will be treated in Advanced Section . Data r$data All of the data retrieved from queries or imported from elsewhere will be available in this variable, which is a tbl . Title You can create a title for your table with r$title , which will be visible as a header. Another style option is r$framedTitle . Go ahead and try it out! The r$title format accepts multiple lines, creating subtitles or passing other info as a header, r$framedTitle accepts only a string, but you may combine them to create interesting headers. # Simple title r$title <- \"Simple title\" # Example with framed title r$framedTitle <- \"Framed title\" # Title with date r$title <- c( \"My title\", looq.titleWithDate(\"Per\u00edod:\", dateInt) ) Style Add styling to single or multiple columns through r$value$Style . Good examples are values that turn red if negative but green if positive. The color can be defined as either hex(#fff) or rgb(255,255,255). # Styling single column r$valueStyle$Column <- style # Styling multiple columns at once r$valueStyle <- list( \"Column1\" = style, \"Column2\" = style ) Formating my data r$valueFormat lets you format numbers and dates, adding percentages, defining number of decimal points son so on. You should write the names of each column followed by the format. r$valueFormat <- list( \"numeric column\" = \"number:2\", \"percent column\" = \"percent:2\" ) Total line Add a total line to your table, it can be defined for each column. If a column is left blank it will be filled with - by default. r$total <- list( `Column 1` = \"total\", `Column 2` = sum(r$data$`Column 2`) ) Drill Down To add drill down options that link to other scripts, you should use r$ValueLink$[Your Column Here] . The question text will be posted as a new question, efectively linking the scripts together. Using paste or paste0 we can add variables or values to the link, or, as you can see below, even add values from within the table, by pasting the desired r$data$column . The \"text\" parameter will add a title to your link, which is essential when multiple drills are made from the same column. # Simple drill r$valueLink$Column <- \"my question text here\" # Simple drill with variable r$valueLink$Column <- paste(\"my question text here with this value\", 203) # Text box drill r$valueLink$Column <- list( list(\"text\" = \"by User\", \"link\" = paste(\"my question with this column\", r$data$Column2)), list(\"text\" = \"by Company\", \"link\" = paste(\"my other question with this column\", r$data$Column2)) ) Pagination Adds pagination of the specified size. r$paginationSize <- 25 Searchbar Boolean that adds a searchbar to the table( FALSE by default). r$searchable <- T Advanced Now that you're already familiar with the basics for creating scripts, we'll begin exploring the full potential of looqbox responses. With more complex functions and different kinds of vizualizations you can bid farewell to the simple tables you learned to create and welcome a whole new range of possibilities. Other Vizualizations Plots When someone thinks of vizualizing data the first thing that pops into mind is a graph. To allow graphs in our scripts we have created looq.objPlotly() , an object which accepts both Plotly and ggplot graphs and histograms as input and adapts them to the interface. Media We also have similar objects that allow you to import media into your answers and compose them with other objects. It is all very straightforward: looq.objImage() : looq.objVideo() : looq.objAudio() : Advanced Package Functions looq.findToken looq.sqlIn looq.sqlUpdate Deeper into looq.objTable","title":"R Scripts"},{"location":"R-Scripts/#r-scripts","text":"This tutorial assumes you don't have any previous knowledge in the Looqbox Package.","title":"R Scripts"},{"location":"R-Scripts/#setup-for-the-tutorial","text":"This documentation's objective is to introduce you to the guidelines for creating organized and efficient R scripts for Looqbox as well as to make you confortable with the looqbox package and with the tool's environment and workflow. In this section we will focus on the creation and editing of the R scripts, so we recomend using Rstudio as the development environment. You can either write the code in your RStudio Serve, or you can set up a local development environment on your computer and use your local RStudio.","title":"Setup for the Tutorial"},{"location":"R-Scripts/#using-looqbox-dev-docker-container","text":"This option is a docker running with a local RStudio linked with your Looqbox-dev folder. First of all you need to install Docker in your local machine. More in docker official site . After installing docker you need to have a looqbox-dev folder in your machine. With the docker and the looqbox-dev folder installed you only need to execute these commands: - docker pull looqboxrep/looqbox-dev to pull the image, use the default looqbox login to pull. - docker run -d --restart=always -v $HOME/looqbox-dev/config:/home/rstudio/looqbox -p 8787:8787 looqboxrep/looqbox-dev . This command will set a local RStudio at port 8787 and will link to your config folder files in the -v command. To open your local RStudio you only have to access localhost:8787 in your browser!","title":"Using Looqbox Dev Docker Container"},{"location":"R-Scripts/#rstudio-serve-setup","text":"This is the quickest way to get started! Open your looqbox instance on port 8787 (usually: http://localhost:8787 ), enter rstudio as username and the password you created in the installation and you're almost ready to go. Under addins, select Looqbox and enter your looqbox username and host (if they're not already there). It is also recomended to have Looqbox opened on another tab, as your tests will be published there. You now have everything you need to begin, go ahead to the basics section .","title":"RStudio Serve Setup"},{"location":"R-Scripts/#basics","text":"","title":"Basics"},{"location":"R-Scripts/#script-sctructure","text":"In this section, you'll learn about the structure in which your script should be implemented.","title":"Script sctructure"},{"location":"R-Scripts/#dependencies","text":"In order to develop a script for Looqbox you should use our Looqbox Package as it allows you to interact with the interface and helps you structure your data to be displayed in our environment. library(\"looqbox\")","title":"Dependencies"},{"location":"R-Scripts/#get_data","text":"This user defined functions is the core of the script, we keep in it all of the data retrieval and manipulation. In it we also receive as parameters the entities collected from the parser and create the objects and vizualizations which will become our response. This function exists to keep the next block (looq.response) as clean and lean as possible. get_data <- function(dateInt, parameter, value){ sql <- \" SELECT EXAMPLE AS Col1, TEST AS Col2, FIELD AS Col3, DATE AS Date FROM example.table WHERE 1=1 AND Date >= DATE_ADD(`1`, INTERVAL +3 HOUR) AND Date < DATE_ADD(`2`, INTERVAL +3 HOUR) AND PARAMETER = `3` AND VALUE = `4` ORDER BY DATE DESC\" r <- looq.sqlExecute(\"myDB\", sql, list(dateInt[1], dateInt[2], parameter, value)) if(r$rows == 0) return(paste(\"No data found from:\\n\", dateInt[1], \"to\", dateInt[2])) r$total <- list( \"Col1\" = \"Total\", \"Col2\" = sum(r$data$Col2) ) r$searcheable <- T r$paginationSize <- 25 r } Above we have a good example of a generic get_data function, it receives some parameters, executes a query that uses them and creates a Looqbox table with a total line, searchbar and pagination. In this case the return is simply r (the looq.objectTable ) because we assume looq.map will be used to call get_data in the looq.response block. Don't worry if you still can't understand what each of these functions do, we have a section dedicated entirely to their study.","title":"get_data"},{"location":"R-Scripts/#looqresponse","text":"This block is where your script's execution will start, it's a S3 object and resembles the common main function. Inside it, you should use looq.lookTag() to receive the value inside a looqbox tag from the parser. In this sample, we are creating a looqbox standard message box and storing it in the msg variable. In the first parameter we paste a string and the quotes entity's value, which was received from the parser. The second parameter message's style type(we will present the options later. Finally, we are creating a looqbox frame with looq.responseFrame() , and so, creating a Looqbox intelligible board. looq.response <- function(par) { # Receives the value inside a looqbox tag. In this case, we're looking for # $quotes tag and storing it in quotes quotes <- looq.lookTag(\"$quotes\", par) # Creates a looqbox standard message box and stores it in msg variable. In # the first parameter we're passing a paste with the string collected above # the second parameter is the style type to display the box. msg <- looq.objMessage( paste(\"Hurray, my installation is working!!\\n\", quotes), \"alert-success\" ) # Creates a looqbox frame to be placed inside a board looq.responseFrame(msg) }","title":"looq.response"},{"location":"R-Scripts/#test-block","text":"This block is a S3 object and is used to test your response from RStudio , allowing you to simulate our parser and test your script without saving it in Looqbox client. If you have configured your Looqbox addin correctly, you can run your script using Ctrl + Shift + S and it will be published to your client. In this block you should assign test values to any entities that your script calls for. looq.testQuestion( list( \"$quotes\" = \"My test sentence\" ) )","title":"Test Block"},{"location":"R-Scripts/#essential-functions","text":"Now that you have a general understanding of how a script is properly constructed, let us go over a few of the package's most important functions. NOTE: In this material we'll be working with practical examples. If you wish to understand the full depth and parameters of each of these functions please refer to the package documentation.","title":"Essential functions"},{"location":"R-Scripts/#looqlooktag","text":"Normally, the first thing your code will do once it enters your looq.response() (main) function, is receive information from the parser (in JSON format). From this, we have to extract information such as entities and tags, which will be used as parameters in get_data() . looq.lookTag() acomplishes this task, searching for specific tags and returning their values. company <- looq.lookTag(\"$company\", par) In the example above, looq.lookTag takes two parameters: \"$company\" : The entity or pattern it will search for. par : the parser string, as received by looq.response(par) It will then, return the company value and assign it to the variable company . If a certain value is an optional parameter for a question, looq.lookTag() also accepts a third parameter for setting a default value (should be a list). date <- looq.lookTag(\"$date\", par, list(c('2018-01-01', '2019-01-01'))) In the code above, if no $date value is recognised by the parser it will choose the default, in this case, the period starting yesterday and ending today (whenever that is).","title":"looq.lookTag"},{"location":"R-Scripts/#looqmap","text":"This function is, perhaps, the core of the whole script. looq.map(get_data, date, company) What it does is fairly simple, the first argument is your get_data() function, and the remaining are variables defined by looq.lookTag() . looq.map() calls the function and passes the variables as arguments to it. Additionally, it wraps everything in a Looqbox response frame making get_data 's output intelligible by the interface.","title":"looq.map"},{"location":"R-Scripts/#looqsqlexecute","text":"Now that we've got looq.response covered, we'll go inside get_data . Think of it as the backstage of your script, it's where everything is prepared so that your main function keeps neat. Most of our scripts involve some kind of query to a database, looq.sqlExecute() is a funtion that makes this interaction extremely simple. # We generally store looq.sqlExecute's output in a variable called r r <- looq.sqlExecute(\"mySQLDev\", sql, list(dateInt[1], dateInt[2], company, value)) # A simple error test follows the query, checking for data absence if(r$rows == 0) return(paste(\"No data found from:\\n\", dateInt[1], \"to\", dateInt[2])) Normally it will take three arguments: \"mySQLDB\" : the database's name, as it was registered in the interface under connections. sql : a string containing the SQL query (we'll cover it in depth) ... : a list of parameters that will be inserted into the query. In a simple manner, looq.sqlExecute does exatly what the name implies, it executes your query within the database, but more than that, it lets you insert values in the query. Take the following example string: sql <- \" SELECT EXAMPLE, TEST, FIELD, DATE FROM example.table WHERE 1=1 AND DATE >= DATE_ADD(`1`, INTERVAL +3 HOUR) AND DATE < DATE_ADD(`2`, INTERVAL +3 HOUR) AND COMPANY = `3` AND VALUE = `4` ORDER BY DATE DESC \" The values between backticks ( ` ` ) are recognised by the function and substituted with the variables passed in the third argument of looq.SQLExecute , in order of appearance. Say that: company <- 0 dateInt <- c('2018-07-09', '2018-08-09') value <- 1120 The query sent to the database would be: SELECT EXAMPLE, TEST, FIELD, DATE FROM my.exampleDB WHERE 1=1 AND DATE >= DATE_ADD('2018-07-09', INTERVAL +3 HOUR) AND DATE < DATE_ADD('2018-08-09', INTERVAL +3 HOUR) AND COMPANY = 0 AND VALUE = 1120 ORDER BY DATE DESC Easy right? And it gets better, looq.sqlExecute returns a looq.objTable , an object from the package that is ready to be imported to the interface.","title":"looq.sqlExecute"},{"location":"R-Scripts/#looqobjtable-and-its-parameters","text":"The most common answer to Looqbox questions comes in the form of tables, but rather than using comon objects as data.frame or tbl we have developed a special object, which is recognised by the interface and will help you create bespoke tables, as it has a number of built-in customization options. Well go through it's most important parameters here, more advanced options will be treated in Advanced Section .","title":"looq.objTable and it's parameters"},{"location":"R-Scripts/#data","text":"r$data All of the data retrieved from queries or imported from elsewhere will be available in this variable, which is a tbl .","title":"Data"},{"location":"R-Scripts/#title","text":"You can create a title for your table with r$title , which will be visible as a header. Another style option is r$framedTitle . Go ahead and try it out! The r$title format accepts multiple lines, creating subtitles or passing other info as a header, r$framedTitle accepts only a string, but you may combine them to create interesting headers. # Simple title r$title <- \"Simple title\" # Example with framed title r$framedTitle <- \"Framed title\" # Title with date r$title <- c( \"My title\", looq.titleWithDate(\"Per\u00edod:\", dateInt) )","title":"Title"},{"location":"R-Scripts/#style","text":"Add styling to single or multiple columns through r$value$Style . Good examples are values that turn red if negative but green if positive. The color can be defined as either hex(#fff) or rgb(255,255,255). # Styling single column r$valueStyle$Column <- style # Styling multiple columns at once r$valueStyle <- list( \"Column1\" = style, \"Column2\" = style )","title":"Style"},{"location":"R-Scripts/#formating-my-data","text":"r$valueFormat lets you format numbers and dates, adding percentages, defining number of decimal points son so on. You should write the names of each column followed by the format. r$valueFormat <- list( \"numeric column\" = \"number:2\", \"percent column\" = \"percent:2\" )","title":"Formating my data"},{"location":"R-Scripts/#total-line","text":"Add a total line to your table, it can be defined for each column. If a column is left blank it will be filled with - by default. r$total <- list( `Column 1` = \"total\", `Column 2` = sum(r$data$`Column 2`) )","title":"Total line"},{"location":"R-Scripts/#drill-down","text":"To add drill down options that link to other scripts, you should use r$ValueLink$[Your Column Here] . The question text will be posted as a new question, efectively linking the scripts together. Using paste or paste0 we can add variables or values to the link, or, as you can see below, even add values from within the table, by pasting the desired r$data$column . The \"text\" parameter will add a title to your link, which is essential when multiple drills are made from the same column. # Simple drill r$valueLink$Column <- \"my question text here\" # Simple drill with variable r$valueLink$Column <- paste(\"my question text here with this value\", 203) # Text box drill r$valueLink$Column <- list( list(\"text\" = \"by User\", \"link\" = paste(\"my question with this column\", r$data$Column2)), list(\"text\" = \"by Company\", \"link\" = paste(\"my other question with this column\", r$data$Column2)) )","title":"Drill Down"},{"location":"R-Scripts/#pagination","text":"Adds pagination of the specified size. r$paginationSize <- 25","title":"Pagination"},{"location":"R-Scripts/#searchbar","text":"Boolean that adds a searchbar to the table( FALSE by default). r$searchable <- T","title":"Searchbar"},{"location":"R-Scripts/#advanced","text":"Now that you're already familiar with the basics for creating scripts, we'll begin exploring the full potential of looqbox responses. With more complex functions and different kinds of vizualizations you can bid farewell to the simple tables you learned to create and welcome a whole new range of possibilities.","title":"Advanced"},{"location":"R-Scripts/#other-vizualizations","text":"","title":"Other Vizualizations"},{"location":"R-Scripts/#plots","text":"When someone thinks of vizualizing data the first thing that pops into mind is a graph. To allow graphs in our scripts we have created looq.objPlotly() , an object which accepts both Plotly and ggplot graphs and histograms as input and adapts them to the interface.","title":"Plots"},{"location":"R-Scripts/#media","text":"We also have similar objects that allow you to import media into your answers and compose them with other objects. It is all very straightforward: looq.objImage() : looq.objVideo() : looq.objAudio() :","title":"Media"},{"location":"R-Scripts/#advanced-package-functions","text":"","title":"Advanced Package Functions"},{"location":"R-Scripts/#looqfindtoken","text":"","title":"looq.findToken"},{"location":"R-Scripts/#looqsqlin","text":"","title":"looq.sqlIn"},{"location":"R-Scripts/#looqsqlupdate","text":"","title":"looq.sqlUpdate"},{"location":"R-Scripts/#deeper-into-looqobjtable","text":"","title":"Deeper into looq.objTable"},{"location":"Read-more/","text":"Read More This section has extra documentation about different areas that don't fall in any other category. RKernel Every R script in Looqbox is processed by a RKernel. RKernels are a logical unit that controls a session in R. The more RKernel available, the more scripts can be processed at the same time. On the other hand, more RAM in consumed. Since a good implementation of R scripts in Looqbox run on average below 2 seconds, even for hundreds of users, only a few RKernels are required (usually between 2 and 6). Don't worry, RKernels are started as needed to processes scripts if the current number is not enough. Every RKernel has a session, so it's possible that during the execution of a script, a RKernel enters in a bad state. In cases that you suspect some kind of bad state is influencing responses, destroy the RKernels. It's also possible that different packages loaded by R scripts have the same function name, in this case, inconsistency can be found while executing different scripts that fall in this case (prefix function calls with the package name to avoid such cases, e.g. httr::config and dplyr::config). In case of a script breaking (syntax error or exceptions), the RKernel is automatically destroyed (saving the last question asked for debugging purposes). If a user asks a question and all RKernels are currently being used to processes other responses, a new RKernel starts, and will be available in the pool. A new RKernel take about 7 seconds to start. Looqbox has the right to limit the number of RKernel available to each client, and if more than 1 on-premise instance of Looqbox is online at the same time for the same company, the total number of RKernels available will be divided between the instances. Available parameters when starting Looqbox The parameters bellow can be added when starting looqbox. Parameter Description -e XMX=\"-Xmx512m\" change maximum heap -e XMS=\"-Xms512m\" change minimum heap -e PORT change Looqbox's port (default 80) -e PROXY_HOST=\"<ip>\" when parameter exists, use host as proxy (must define proxy_port as well) -e PROXY_PORT=\"<port>\" when parameter exists, use port as proxy (must define proxy_host as well) Examples To configure a proxy: docker run -d --restart=always --name=looqbox-instance -e PROXY_HOST=\"127.0.0.1\" -e PROXY_PORT=\"8080\" -e CLIENT=\"<client name>\" -e KEY=\"<client key>\" -e RSTUDIO_PASS=\"<choose a password>\" -p 80:80 -p 8787:8787 looqboxrep/fes-public:cloud002 To change the initial memory used by Java (default is 2Gb): docker run -d --restart=always --name=looqbox-instance -e XMX=\"-Xmx512m\" -e XMS=\"-Xms512m\" -e CLIENT=\"<client name>\" -e KEY=\"<client key>\" -e RSTUDIO_PASS=\"<choose a password>\" -p 80:80 -p 8787:8787 looqboxrep/fes-public:cloud002 It's not recommeded to use bellow 512mb. Looqbox is not a full stateless service, don't use it in High Availability without contacting our support. Docker commands for looqbox Those are the most common Docker commands that will be used with Looqbox. Execute them in the order below to update Looqbox's version. Stop Looqbox's container docker stop looqbox-instance Remove Looqbox's image :( docker rm looqbox-instance Pull new version docker pull looqboxrep/fes-public:cloud002 Start Looqbox docker run -d --restart=always --name=looqbox-instance -e CLIENT=\"<client name>\" -e KEY=\"<client key>\" -e RSTUDIO_PASS=\"<choose a password>\" -p 80:80 -p 8787:8787 looqboxrep/fes-public:cloud002 Check looqbox's logs docker logs -f --tail 200 looqbox-instance","title":"Read More"},{"location":"Read-more/#read-more","text":"This section has extra documentation about different areas that don't fall in any other category.","title":"Read More"},{"location":"Read-more/#rkernel","text":"Every R script in Looqbox is processed by a RKernel. RKernels are a logical unit that controls a session in R. The more RKernel available, the more scripts can be processed at the same time. On the other hand, more RAM in consumed. Since a good implementation of R scripts in Looqbox run on average below 2 seconds, even for hundreds of users, only a few RKernels are required (usually between 2 and 6). Don't worry, RKernels are started as needed to processes scripts if the current number is not enough. Every RKernel has a session, so it's possible that during the execution of a script, a RKernel enters in a bad state. In cases that you suspect some kind of bad state is influencing responses, destroy the RKernels. It's also possible that different packages loaded by R scripts have the same function name, in this case, inconsistency can be found while executing different scripts that fall in this case (prefix function calls with the package name to avoid such cases, e.g. httr::config and dplyr::config). In case of a script breaking (syntax error or exceptions), the RKernel is automatically destroyed (saving the last question asked for debugging purposes). If a user asks a question and all RKernels are currently being used to processes other responses, a new RKernel starts, and will be available in the pool. A new RKernel take about 7 seconds to start. Looqbox has the right to limit the number of RKernel available to each client, and if more than 1 on-premise instance of Looqbox is online at the same time for the same company, the total number of RKernels available will be divided between the instances.","title":"RKernel"},{"location":"Read-more/#available-parameters-when-starting-looqbox","text":"The parameters bellow can be added when starting looqbox. Parameter Description -e XMX=\"-Xmx512m\" change maximum heap -e XMS=\"-Xms512m\" change minimum heap -e PORT change Looqbox's port (default 80) -e PROXY_HOST=\"<ip>\" when parameter exists, use host as proxy (must define proxy_port as well) -e PROXY_PORT=\"<port>\" when parameter exists, use port as proxy (must define proxy_host as well)","title":"Available parameters when starting Looqbox"},{"location":"Read-more/#examples","text":"To configure a proxy: docker run -d --restart=always --name=looqbox-instance -e PROXY_HOST=\"127.0.0.1\" -e PROXY_PORT=\"8080\" -e CLIENT=\"<client name>\" -e KEY=\"<client key>\" -e RSTUDIO_PASS=\"<choose a password>\" -p 80:80 -p 8787:8787 looqboxrep/fes-public:cloud002 To change the initial memory used by Java (default is 2Gb): docker run -d --restart=always --name=looqbox-instance -e XMX=\"-Xmx512m\" -e XMS=\"-Xms512m\" -e CLIENT=\"<client name>\" -e KEY=\"<client key>\" -e RSTUDIO_PASS=\"<choose a password>\" -p 80:80 -p 8787:8787 looqboxrep/fes-public:cloud002 It's not recommeded to use bellow 512mb. Looqbox is not a full stateless service, don't use it in High Availability without contacting our support.","title":"Examples"},{"location":"Read-more/#docker-commands-for-looqbox","text":"Those are the most common Docker commands that will be used with Looqbox. Execute them in the order below to update Looqbox's version.","title":"Docker commands for looqbox"},{"location":"Read-more/#stop-looqboxs-container","text":"docker stop looqbox-instance","title":"Stop Looqbox's container"},{"location":"Read-more/#remove-looqboxs-image","text":"docker rm looqbox-instance","title":"Remove Looqbox's image :("},{"location":"Read-more/#pull-new-version","text":"docker pull looqboxrep/fes-public:cloud002","title":"Pull new version"},{"location":"Read-more/#start-looqbox","text":"docker run -d --restart=always --name=looqbox-instance -e CLIENT=\"<client name>\" -e KEY=\"<client key>\" -e RSTUDIO_PASS=\"<choose a password>\" -p 80:80 -p 8787:8787 looqboxrep/fes-public:cloud002","title":"Start Looqbox"},{"location":"Read-more/#check-looqboxs-logs","text":"docker logs -f --tail 200 looqbox-instance","title":"Check looqbox's logs"}]}