{
    "docs": [
        {
            "location": "/",
            "text": "Home\n\n\n\n  \n\n\n\n\n\nIntroduction\n\n\nInstallation\n\n\nLooqbox must be installed in a Linux distribution that supports docker (e.g. Ubuntu 18.04 LTS).\n\n\nAfter \ninstalling docker\n, start Looqbox's container:\n\n\ndocker run -d --restart=always --name=looqbox-instance -e CLIENT=\"<client name>\" -e KEY=\"<client key>\" -e RSTUDIO_PASS=\"<choose a password>\" -p 80:80 -p 8787:8787 looqboxrep/fes-public:cloud002\n\n\n\n\nTo check if looqbox started correctly, run: \n\n\ndocker logs -f --tail 200 looqbox-instance\n\n\n\n\nExpected result:\n\n\n  \n\n\n\n\nYou can now access looqbox in port 80 (if it's a local instalation: \nlocalhost\n)\n\n\nAvailable parameters\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-e XMX=\"-Xmx512m\"\n\n\nchange maximum heap\n\n\n\n\n\n\n-e XMS=\"-Xms512m\"\n\n\nchange minimum heap\n\n\n\n\n\n\n-e PORT\n\n\nchange Looqbox's port (default 80)\n\n\n\n\n\n\n-e PROXY_HOST=\"<ip>\"\n\n\nwhen parameter exists, use host as proxy (must define proxy_port as well)\n\n\n\n\n\n\n-e PROXY_PORT=\"<port>\"\n\n\nwhen parameter exists, use port as proxy (must define proxy_host as well)\n\n\n\n\n\n\n\n\nAll script files and configurations are backed up in Looqbox's Cloud. To transfer all your work between your local machine and a server, all you need to do is rerun the docker command above. It will automatically download all files to the new instance.\n\n\nTo update Looqbox and Looqbox's R package, pull the image's newest version and start a new container.\n\n\nYour first script\n\n\n\n\nClick in settings in the right upper corner and then in Admin.\n\n\nFind Responses and click it.\n\n\nPress \nNew +\n button and fill it with the following fields:\n\n\nResponse Name:\n helloWorld\n\n\nResponse Group:\n admin\n\n\nLanguage:\n pt-br\n\n\nKeyword:\n\n\nhello\n\n\nworld\n\n\nscript\n\n\n$quotes\n\n\n\n\n\n\nExample:\n hello world script \"this is my first script\"\n\n\n\n\n\n\nPress the green button \nCreate new\n at the botton.\n\n\nFind \nResponse Files\n and press \nnew\n in \nmain file missing (new)\n.\n\n\nPress \n+ show editor\n button.\n\n\nCopy the complete script in our \nGithub\n or copy the code below, paste it and press \nsave\n button. \n\n\nClick at Looqbox image and type \nhello world script \"any message that you want\"\n. If the return was a message green box with the message \nHurray, my installation is working!!\n in the first line and the message you wrote in the second line, your installation is complete.\n\n\n\n\n# In order to develop a script for Looqbox you should use our Looqbox Package.\n# The package allows you to interact with the interface and help you structure\n# your data to be displayed in our client.\nlibrary(looqbox)\n\n#-----------------------------------------------------------------------------#\n#---  Response\n#---\n#--- This block is where your script will start the execution, simulating a \n#--- main function. Inside it, you should set your parameters got from parser\n#-----------------------------------------------------------------------------#\nlooq.response <- function(par) {\n\n  # Receives the value inside a looqbox tag. In this case, we're looking for \n  # $quotes tag and storing it in quotes\n  quotes <- looq.lookTag(\"$quotes\", par)\n\n  # Creates a looqbox standard message box and store it in msg variable. In\n  # the first parameter we're passing a paste with the string collected above\n  # the second parameter is the style type to display the box. \n  msg <- looq.objMessage(\n    paste(\"Hurray, my installation is working!!\\n\", quotes),\n    \"alert-success\"\n  )\n\n  # Creates a looqbox frame to be placed inside a board\n  looq.responseFrame(msg)\n}\n\n#-----------------------------------------------------------------------------#\n#--- Test Block\n#\n#--- This block is used to test your response, allowing you to simulate our\n#--- parser and test your script without saving it in Looqbox client.\n#---\n#--- If you have configured your Looqbox addin correctly, you can run your \n#--- script using Ctrl + Shift + S and it will be displayed in your client.\n#-----------------------------------------------------------------------------#\nlooq.testQuestion(\n  list(\n    \"$quotes\" = \"My test sentence\"\n  )\n)\n\n\n\n\n\n\nAre you ready to learn more about Looqbox? Click \nhere\n to continue.",
            "title": "Home"
        },
        {
            "location": "/#home",
            "text": "",
            "title": "Home"
        },
        {
            "location": "/#introduction",
            "text": "",
            "title": "Introduction"
        },
        {
            "location": "/#installation",
            "text": "Looqbox must be installed in a Linux distribution that supports docker (e.g. Ubuntu 18.04 LTS).  After  installing docker , start Looqbox's container:  docker run -d --restart=always --name=looqbox-instance -e CLIENT=\"<client name>\" -e KEY=\"<client key>\" -e RSTUDIO_PASS=\"<choose a password>\" -p 80:80 -p 8787:8787 looqboxrep/fes-public:cloud002  To check if looqbox started correctly, run:   docker logs -f --tail 200 looqbox-instance  Expected result: \n     You can now access looqbox in port 80 (if it's a local instalation:  localhost )",
            "title": "Installation"
        },
        {
            "location": "/#available-parameters",
            "text": "Parameter  Description      -e XMX=\"-Xmx512m\"  change maximum heap    -e XMS=\"-Xms512m\"  change minimum heap    -e PORT  change Looqbox's port (default 80)    -e PROXY_HOST=\"<ip>\"  when parameter exists, use host as proxy (must define proxy_port as well)    -e PROXY_PORT=\"<port>\"  when parameter exists, use port as proxy (must define proxy_host as well)     All script files and configurations are backed up in Looqbox's Cloud. To transfer all your work between your local machine and a server, all you need to do is rerun the docker command above. It will automatically download all files to the new instance.  To update Looqbox and Looqbox's R package, pull the image's newest version and start a new container.",
            "title": "Available parameters"
        },
        {
            "location": "/#your-first-script",
            "text": "Click in settings in the right upper corner and then in Admin.  Find Responses and click it.  Press  New +  button and fill it with the following fields:  Response Name:  helloWorld  Response Group:  admin  Language:  pt-br  Keyword:  hello  world  script  $quotes    Example:  hello world script \"this is my first script\"    Press the green button  Create new  at the botton.  Find  Response Files  and press  new  in  main file missing (new) .  Press  + show editor  button.  Copy the complete script in our  Github  or copy the code below, paste it and press  save  button.   Click at Looqbox image and type  hello world script \"any message that you want\" . If the return was a message green box with the message  Hurray, my installation is working!!  in the first line and the message you wrote in the second line, your installation is complete.   # In order to develop a script for Looqbox you should use our Looqbox Package.\n# The package allows you to interact with the interface and help you structure\n# your data to be displayed in our client.\nlibrary(looqbox)\n\n#-----------------------------------------------------------------------------#\n#---  Response\n#---\n#--- This block is where your script will start the execution, simulating a \n#--- main function. Inside it, you should set your parameters got from parser\n#-----------------------------------------------------------------------------#\nlooq.response <- function(par) {\n\n  # Receives the value inside a looqbox tag. In this case, we're looking for \n  # $quotes tag and storing it in quotes\n  quotes <- looq.lookTag(\"$quotes\", par)\n\n  # Creates a looqbox standard message box and store it in msg variable. In\n  # the first parameter we're passing a paste with the string collected above\n  # the second parameter is the style type to display the box. \n  msg <- looq.objMessage(\n    paste(\"Hurray, my installation is working!!\\n\", quotes),\n    \"alert-success\"\n  )\n\n  # Creates a looqbox frame to be placed inside a board\n  looq.responseFrame(msg)\n}\n\n#-----------------------------------------------------------------------------#\n#--- Test Block\n#\n#--- This block is used to test your response, allowing you to simulate our\n#--- parser and test your script without saving it in Looqbox client.\n#---\n#--- If you have configured your Looqbox addin correctly, you can run your \n#--- script using Ctrl + Shift + S and it will be displayed in your client.\n#-----------------------------------------------------------------------------#\nlooq.testQuestion(\n  list(\n    \"$quotes\" = \"My test sentence\"\n  )\n)",
            "title": "Your first script"
        },
        {
            "location": "/#are-you-ready-to-learn-more-about-looqbox-click-here-to-continue",
            "text": "",
            "title": "Are you ready to learn more about Looqbox? Click here to continue."
        },
        {
            "location": "/implementation/",
            "text": "Implementation\n\n\nImplementation Flow\n\n\nThere are 2 important concepts that you should know to understand our recommentation about how responses should be implemented in Looqbox.\n\n\n\n\n\n\nLooqbox runs a R script for each question asked by the users. Each of those scripts access a datasource (e.g. MySQL), so the time that a users waits is mainly the response time from the query or API. The maximum recommended time for a response is 2 seconds.\n\n\n\n\n\n\nUsers usually need a bit of experience with the interface to start asking more complex questions, so starting with short and general questions help new users to navigate.\n\n\n\n\n\n\nWe discorage the implementation of complex dashboards in Looqbox, since it usually depends of multiple queries, which result in a long response time.\n\n\nTo guarantee the best user experience, responses should be implemented in a way that users can ask simple questions, and navigate to more specific information using features like drill down. Navigating between 4 tables of content waiting 2 seconds for each load in much better than waiting 8 seconds for a single dashboard.\n\n\nHere is a sequence of questions to illustrate this scenario:\n\n\n\n\nsales $date\n\n\nsales $date by store\n\n\nsales $date by department\n\n\nsales $date by supplier\n\n\n\n\nDatabase Connection\n\n\nCreating a response\n\n\nHere you can link keywords to a script. \nWe will divide this section 3 parts.\n\n\nBasic info\n\n\nResponse Name: use a name to find this response easily later\n\n\nResponse Group: each response must belong to a response group, used to control who can access this resource\n\n\nEngine: R (default) is the only engine available for scripts\n\n\nCustom evaluation time limit: ATTENTION. Don't modify unless it's extremely necessary. This field is used to modify the default timeout (30s) for a script to respond. Good scripts run under 2 seconds, so there should be really no reason to modify this value\n\n\nActive: (self explanatory)\n\n\nResponse files\n\n\nResponse files: Use this area to upload scripts or help files. The main file will/must always have the same name as the responseName. \nIMPORTANT\n: .r extension MUST be lowercase\n\n\nKeyword Group\n\n\nLanguage: language that will use this keyword group\n\n\nKeyword: \nIMPORTANT\n. Here you can define which keywords must be present in a sentence to run this response. The script that will be executed will always be chosen by the highest number of entities found inside a question that in linked to a response.\nKeywords can be divided in 2 groups:\n\n\n\n\nsimple words: usually stem or a verb in infitive. E.g. for a report about sales, use as keyword \"sales\", and all variations such as \"sell\", \"sold\", \"selling\" can be registered under \nReplacements\n. \n\n\nentities: starts with \"$\", and represent a pattern that can be found in the question. The most used entity is \"$date\", which is preimplemented by Looqbox. You can create your own entities (see \nEntityByCode\n and \nEntityByName\n)\n\n\n\n\nA list of synonyms can be used by separating words with pipes. E.g.: sales|revenue\n\n\nNote that keywords can be optional. This is useful for entites that may appear in a question, but is not fundamental for the main usage case for a response. To illustrate:\n\n\n\n\nImagine that it's important for a user to ask about sales \"sales yesterday\" (which returns a table with the sales in each store), but it's also common to modify the answer by asking \"sales yesterday store 1, 2 and 3\" (which returns a table with the sales of store 1, 2 and 3). In this case, the entity $store is optional, and when available, all values about store (in our example, 1 to 3) will be fowarded to the script within the entity $store.\n\n\n\n\n\n  \n\n\n\n\n\nCreating User\n\n\nIn this section you are able to create users that will have access to Looqbox.\n\n\nUser Login: name used by the user to login.\n\n\nShort Name: alias for the user.\n\n\nEmail: used when a user forgets the password.\n\n\nPassword: (self explanatory)\n\n\nUser Group: Each user must have a \nUser Group\n. User groups are usually divided in roles inside a company (sales, marketing etc)l\n\n\nLanguage: default language for this user.\n\n\nAdmin: select if a user can edit user, responses, entities and so on.\n\n\nActive: (self explanatory)\n\n\n\n  \n\n\n\n\n\nCreating UserGroup\n\n\nUser groups are usually divided in roles inside a company (sales, marketing etc).\nWhen \ncreating users\n, you can define which userGroup this user belongs to.\n\n\nResponse Groups: Define which \nResponse Groups\n are linked to this user group. \n\n\nUser Group Suggestions: Suggestions added will be shown to users that belong to this userGroup in the favorites and autocomplete.\n\n\n\n  \n\n\n\n\n\nCreating ResponseGroup\n\n\nEach \nresponse\n belongs to a single responseGroup. When \ncreating userGroups\n, you can choose multiple responseGroups that access is allowed to the userGroup.\n\n\nResponse Group Name: define a name for a responseGroup. \n\n\n\n  \n\n\n\n\n\nEntity\n\n\nEntities are patterns that can be found in the question, and retrieved as values to be used inside scripts.\n\n\nThe most used entity is \"$date\", which is preimplemented by Looqbox. Other entities can be implemented as you need.\n\n\nE.g.: \"sales last week\" -> $date: [2018-09-10, 2018-09-16]\n\n\nDefault entities by Looqbox\n\n\n$date\n\n\n$datePartition\n\n\n$comparative\n\n\n$topN\n\n\n$email\n\n\n$quotes\n\n\n$diamond\n\n\nEntity By Code\n\n\nEntity By Name\n\n\nReplacements",
            "title": "Implementation"
        },
        {
            "location": "/implementation/#implementation",
            "text": "",
            "title": "Implementation"
        },
        {
            "location": "/implementation/#implementation-flow",
            "text": "There are 2 important concepts that you should know to understand our recommentation about how responses should be implemented in Looqbox.    Looqbox runs a R script for each question asked by the users. Each of those scripts access a datasource (e.g. MySQL), so the time that a users waits is mainly the response time from the query or API. The maximum recommended time for a response is 2 seconds.    Users usually need a bit of experience with the interface to start asking more complex questions, so starting with short and general questions help new users to navigate.    We discorage the implementation of complex dashboards in Looqbox, since it usually depends of multiple queries, which result in a long response time.  To guarantee the best user experience, responses should be implemented in a way that users can ask simple questions, and navigate to more specific information using features like drill down. Navigating between 4 tables of content waiting 2 seconds for each load in much better than waiting 8 seconds for a single dashboard.  Here is a sequence of questions to illustrate this scenario:   sales $date  sales $date by store  sales $date by department  sales $date by supplier",
            "title": "Implementation Flow"
        },
        {
            "location": "/implementation/#database-connection",
            "text": "",
            "title": "Database Connection"
        },
        {
            "location": "/implementation/#creating-a-response",
            "text": "Here you can link keywords to a script. \nWe will divide this section 3 parts.",
            "title": "Creating a response"
        },
        {
            "location": "/implementation/#basic-info",
            "text": "Response Name: use a name to find this response easily later  Response Group: each response must belong to a response group, used to control who can access this resource  Engine: R (default) is the only engine available for scripts  Custom evaluation time limit: ATTENTION. Don't modify unless it's extremely necessary. This field is used to modify the default timeout (30s) for a script to respond. Good scripts run under 2 seconds, so there should be really no reason to modify this value  Active: (self explanatory)",
            "title": "Basic info"
        },
        {
            "location": "/implementation/#response-files",
            "text": "Response files: Use this area to upload scripts or help files. The main file will/must always have the same name as the responseName.  IMPORTANT : .r extension MUST be lowercase",
            "title": "Response files"
        },
        {
            "location": "/implementation/#keyword-group",
            "text": "Language: language that will use this keyword group  Keyword:  IMPORTANT . Here you can define which keywords must be present in a sentence to run this response. The script that will be executed will always be chosen by the highest number of entities found inside a question that in linked to a response.\nKeywords can be divided in 2 groups:   simple words: usually stem or a verb in infitive. E.g. for a report about sales, use as keyword \"sales\", and all variations such as \"sell\", \"sold\", \"selling\" can be registered under  Replacements .   entities: starts with \"$\", and represent a pattern that can be found in the question. The most used entity is \"$date\", which is preimplemented by Looqbox. You can create your own entities (see  EntityByCode  and  EntityByName )   A list of synonyms can be used by separating words with pipes. E.g.: sales|revenue  Note that keywords can be optional. This is useful for entites that may appear in a question, but is not fundamental for the main usage case for a response. To illustrate:   Imagine that it's important for a user to ask about sales \"sales yesterday\" (which returns a table with the sales in each store), but it's also common to modify the answer by asking \"sales yesterday store 1, 2 and 3\" (which returns a table with the sales of store 1, 2 and 3). In this case, the entity $store is optional, and when available, all values about store (in our example, 1 to 3) will be fowarded to the script within the entity $store.",
            "title": "Keyword Group"
        },
        {
            "location": "/implementation/#creating-user",
            "text": "In this section you are able to create users that will have access to Looqbox.  User Login: name used by the user to login.  Short Name: alias for the user.  Email: used when a user forgets the password.  Password: (self explanatory)  User Group: Each user must have a  User Group . User groups are usually divided in roles inside a company (sales, marketing etc)l  Language: default language for this user.  Admin: select if a user can edit user, responses, entities and so on.  Active: (self explanatory)",
            "title": "Creating User"
        },
        {
            "location": "/implementation/#creating-usergroup",
            "text": "User groups are usually divided in roles inside a company (sales, marketing etc).\nWhen  creating users , you can define which userGroup this user belongs to.  Response Groups: Define which  Response Groups  are linked to this user group.   User Group Suggestions: Suggestions added will be shown to users that belong to this userGroup in the favorites and autocomplete.",
            "title": "Creating UserGroup"
        },
        {
            "location": "/implementation/#creating-responsegroup",
            "text": "Each  response  belongs to a single responseGroup. When  creating userGroups , you can choose multiple responseGroups that access is allowed to the userGroup.  Response Group Name: define a name for a responseGroup.",
            "title": "Creating ResponseGroup"
        },
        {
            "location": "/implementation/#entity",
            "text": "Entities are patterns that can be found in the question, and retrieved as values to be used inside scripts.  The most used entity is \"$date\", which is preimplemented by Looqbox. Other entities can be implemented as you need.  E.g.: \"sales last week\" -> $date: [2018-09-10, 2018-09-16]",
            "title": "Entity"
        },
        {
            "location": "/implementation/#default-entities-by-looqbox",
            "text": "",
            "title": "Default entities by Looqbox"
        },
        {
            "location": "/implementation/#date",
            "text": "",
            "title": "$date"
        },
        {
            "location": "/implementation/#datepartition",
            "text": "",
            "title": "$datePartition"
        },
        {
            "location": "/implementation/#comparative",
            "text": "",
            "title": "$comparative"
        },
        {
            "location": "/implementation/#topn",
            "text": "",
            "title": "$topN"
        },
        {
            "location": "/implementation/#email",
            "text": "",
            "title": "$email"
        },
        {
            "location": "/implementation/#quotes",
            "text": "",
            "title": "$quotes"
        },
        {
            "location": "/implementation/#diamond",
            "text": "",
            "title": "$diamond"
        },
        {
            "location": "/implementation/#entity-by-code",
            "text": "",
            "title": "Entity By Code"
        },
        {
            "location": "/implementation/#entity-by-name",
            "text": "",
            "title": "Entity By Name"
        },
        {
            "location": "/implementation/#replacements",
            "text": "",
            "title": "Replacements"
        },
        {
            "location": "/tutorial/",
            "text": "R Tutorial\n\n\n\n\nThis tutorial assumes you don't have any previous knowledge in the Looqbox Package.\n\n\n\n\n\n\n\nSetup for the Tutorial\n\n\nThis documentation's objective is to introduce you to the guidelines for creating organized and efficient R scripts for Looqbox as well as to make you confortable with the looqbox package and with the tool's environment and workflow. In this section we will focus on the creation and editing of the R scripts, so we recomend using Rstudio as the development environment.\n\n\nYou can either write the code in your RStudio Serve, or you can set up a local development environment on your computer and use your local RStudio.\n\n\nSetup 1: RStudio Serve\n\n\nThis is the quickest way to get started!\n\n\nOpen your looqbox instance on port 8787 (usually: \nhttp://localhost:8787\n), enter your \nusername\n and \npassword\n and you're almost ready to go.\n\n\nUnder addins, select Looqbox and enter your admin \nusername\n and \nhost\n (if they're not already there).\n\n\n\n  \n\n\n\n\n\nIt is also recomended to have Looqbox opened on another tab, as your tests will be published there.\n\n\nYou now have everything you need to begin, go ahead to the \nbasics section\n.\n\n\nSetup 2: Local development environment\n\n\nThis setup option requires a little more work at first glance, but it certainly pays off. \n\n\nDownloads\n\n\n\n\nR: \nhttps://cran.r-project.org/bin/macosx/el-capitan/base/\n\n\nRStudio: \nhttps://www.rstudio.com/products/rstudio/#Desktop\n\n\nLocal Rstudio configuration file: \nDownload\n\n\n\n\nConfiguration\n\n\nTo configure your local Rstudio environment to work with Looqbox's Rprofile, download the files listed above and extract the configuration file in your home directory (the \nlooqbox-dev\n folder should appear).Open the terminal, \ncd\n to your looqbox-dev directory and execute \nsetProfile.sh\n or run:\n\n\nbash ~/looqbox-dev/setProfile.sh\n\n\n\n\nTo set up your user in RStudio you can either go to the Looqbox Addin, as described in \nSetup 1\n or edit the \nconfig/R/config.json\n file and enter your looqbox username.\n\n\nSee, it wasn't even that hard, and now you're set up to work from your local environment!\n\n\nBasics\n\n\nScript sctructure\n\n\nIn this section, you'll learn about the structure that your script should be implemented.\n\n\nDependencies\n\n\nIn order to develop a script for Looqbox you should use our Looqbox Package. The package allows you to interact with the interface and help you structure your data to be displayed in our client.\n\n\nlibrary(looqbox)\n\n\n\n\nget.data\n\n\nlooq.response\n\n\nThis block is where your script will start the execution, simulating a main function. Inside it, you should use \nlooq.lookTag()\n  to receive the value inside a looqbox tag from the parser.\n\n\nIn this case, we are creating a looqbox standard message box and storing it in msg variable. In the first parameter we're passing a \npaste\n with the string collected above. The second parameter is the style type to display the box. \n\n\nFinally, we are creating a looqbox frame to be placed inside a board with \nlooq.responseFrame()\n.\n\n\nlooq.response <- function(par) {\n\n  # Receives the value inside a looqbox tag. In this case, we're looking for \n  # $quotes tag and storing it in quotes\n  quotes <- looq.lookTag(\"$quotes\", par)\n\n  # Creates a looqbox standard message box and store it in msg variable. In\n  # the first parameter we're passing a paste with the string collected above\n  # the second parameter is the style type to display the box. \n  msg <- looq.objMessage(\n    paste(\"Hurray, my installation is working!!\\n\", quotes),\n    \"alert-success\"\n  )\n\n  # Creates a looqbox frame to be placed inside a board\n  looq.responseFrame(msg)\n}\n\n\n\n\nTest Block\n\n\nThis block is used to test your response from \nRStudio\n, allowing you to simulate our parser and test your script without saving it in Looqbox client. If you have configured your Looqbox addin correctly, you can run your script using \nCtrl + Shift + S\n and it will be displayed in your client.\n\n\nlooq.testQuestion(\n  list(\n    \"$quotes\" = \"My test sentence\"\n  )\n)\n\n\n\n\nEssential functions\n\n\nNow that you have a general understanding of how a script is properly constructed, let us go over a few of the package's most important functions. \n\n\nNOTE: In this material we'll be working with practical examples. If you wish to understand the full depth and parameters of each of these functions please refer to the package documentation or Looqbox wiki.[ver depois]\n\n\nlooq.lookTag\n\n\nNormally, the first thing your code will do once it enters your \nlooq.response()\n(main) function, is receive information from the parser (in JSON format). From this, we have to extract information such as entities and tags, which will be used as parameters in \nget.data()\n. \n\n\n\n\nlooq.lookTag()\n acomplishes this task, searching for specific tags and returning their values.\n\n\n\n\ncompany <- looq.lookTag(\"$company\", par)\n\n\n\n\nIn the example above, \nlooq.lookTag\n takes two parameters:\n\n\n\n\n\"$company\"\n: The entity or pattern it will search for. \n\n\npar\n: the parser string, as received by \nlooq.response(par)\n \n\n\n\n\nIt will then, return the company value and assign it to the variable \ncompany\n.\n\n\nIf a certain value is an optional parameter for a question, \nlooq.lookTag()\n also accepts a third parameter for setting a default value (should be a list). \n\n\ndate <- looq.lookTag(\"$date\", par, list(c('2018-01-01', '2019-01-01')))\n\n\n\n\nIn the code above, if no \n$date\n value is recognised by the parser it will choose the default, in this case, the period starting yesterday and ending today (whenever that is).\n\n\nlooq.map\n\n\nThis function is, perhaps, the core of the whole script.\n\n\nlooq.map(get.data, date, company)\n\n\n\n\nWhat it does is fairly simple, the first argument is your \nget.data()\n function, and the remaining are  variables defined by \nlooq.lookTag()\n. \n\n\n\n\nlooq.map()\n calls the function and passes the variables as arguments to it.\n\n\nAdditionally, it wraps everything in a Looqbox response frame making \nget.data\n's \noutput intelligible by the interface. \n\n\n\n\nlooq.sqlExecute\n\n\nNow that we've got \nlooq.response\n covered, we'll go inside \nget.data\n. Think of it as the backstage of your script, it's where everything is prepared so that your main function keeps neat.\n\n\nMost of our scripts involve some kind of query to a database, \nlooq.sqlExecute()\n is a funtion that makes this interaction extremely simple. \n\n\n# We generally store looq.sqlExecute's output in a variable called r\nr <- looq.sqlExecute(\"mySQLDev\", sql, list(dateInt[1], dateInt[2], company, value))\n\n# A simple error test follows the query, checking for data absence\nif(r$rows == 0) return(paste(\"No data found from:\\n\", dateInt[1], \"to\", dateInt[2]))\n\n\n\n\nNormally it will take three arguments:\n\n\n\n\n\"mySQLDB\"\n: the database's name, as it was registered in the interface under connections.\n\n\nsql\n: a string containing the SQL query (we'll cover it in depth) \n\n\n...\n: a list of parameters that will be inserted into the query.\n\n\n\n\nIn a simple manner, \nlooq.sqlExecute\n does exatly what the name implies, it executes your query within the database, but more than that, it lets you insert values in the query. Take the following example string:\n\n\nsql <- \"\n    SELECT\n        EXAMPLE,\n        TEST,\n        FIELD,\n        DATE\n    FROM example.table\n    WHERE 1=1           \n        AND DATE >= DATE_ADD(`1`, INTERVAL +3 HOUR) \n        AND DATE < DATE_ADD(`2`, INTERVAL +3 HOUR)\n        AND COMPANY = `3`\n        AND VALUE = `4`\n    ORDER BY DATE DESC\n\"\n\n\n\n\nThe values between backticks (\n` `\n)  are recognised by the function and substituted with the variables passed in the third argument of \nlooq.SQLExecute\n, in order of appearance. \n\n\nSay that:\n\n\ncompany <- 0\ndateInt <- c('2018-07-09', '2018-08-09')\nvalue <- 1120\n\n\n\n\nThe query sent to the database would be:\n\n\nSELECT\n    EXAMPLE,\n    TEST,\n    FIELD,\n    DATE\nFROM my.exampleDB\nWHERE 1=1\n    AND DATE >= DATE_ADD('2018-07-09', INTERVAL +3 HOUR) \n    AND DATE < DATE_ADD('2018-08-09', INTERVAL +3 HOUR)\n    AND COMPANY = 0\n    AND VALUE = 1120\nORDER BY DATE DESC\n\n\n\n\nEasy right? And it gets better, \nlooq.sqlExecute\n returns a \nlooq.objTable\n, an object from the package that is ready to be imported to the interface.\n\n\nlooq.objTable and it's fields\n\n\nThe most common answer to Looqbox questions comes in the form of tables, but rather than using comon objects as \ndata.frame\n or \ntbl\n we have developed a special object, which is recognised by the interface and will help you create espoke tables, as it has a number of built-in customization options.\n\n\nWell go through it's most important parameters here, more advanced options will be treated in the \n\nAdvanced Section\n.\n\n\nData\n\n\nr$data\n\n\n\n\nAll of the data retrieved from queries or imported from elsewhere will be available in this variable, which is a \ntbl\n. \n\n\nTitle\n\n\nYou can create a title for your table with \nr$title\n, which will be visible as a header. Another style option is \nr$framedTitle\n. Go ahead and try it out!\n\n\nThe \nr$title\n format accepts multiple lines, creating subtitles or passing other info as a header, \nr$framedTitle\n accepts only a string, but you may combine them to create interesting headers.\n\n\n# Simple title\nr$title <- \"Simple title\"\n\n# Example with framed title\nr$framedTitle <- \"Framed title\"\n\n# Title with date\nr$title <- c(\n    \"My title\",\n    looq.titleWithDate(\"Per\u00edod:\", dateInt)\n)\n\n\n\n\nStyle\n\n\nAdd styling to single or multiple columns through \nr$value$Style\n. Good examples are values that turn red if negative but green if positive. The color can be defined as either hex(#fff) or rgb(255,255,255). \n\n\n\n# Styling single column\nr$valueStyle$Column <- style\n\n# Styling multiple columns at once\nr$valueStyle <- list(\n    \"Column1\" = style,\n    \"Column2\" = style\n)\n\n\n\n\nFormating my data\n\n\nr$valueFormat\n lets you format numbers and dates, adding percentages, defining number of decimal points son so on.  You should write the names of each column followed by the format.\n\n\nr$valueFormat <- list(\n    \"numeric column\" = \"number:2\",\n    \"percent column\" = \"percent:2\"\n)\n\n\n\n\nTotal line\n\n\nAdd a total line to your table, it can be defined for each column. If a column is left blank it will be filled with \n-\n by default.\n\n\nr$total <- list(\n    `Column 1` = \"total\",\n    `Column 2` = sum(r$data$`Column 2`)\n)\n\n\n\n\nDrill Down\n\n\nTo add drill down options that link to other scripts, you should use \nr$ValueLink$[Your Column Here]\n. The question text will be posted as a new question, efectively linking the scripts together. \n\n\nUsing \npaste\n or \npaste0\n we can ad variables or values to the link, or, as you can see below, even add values from within the table, by pasting the desired \nr$data$column\n. \n\n\nThe \n\"text\"\n parameter will add a title to your link, which is essential when multiple drills are made from the same column.\n\n\n# Simple drill\nr$valueLink$Column <- \"my question text here\"\n\n# Simple drill with variable\nr$valueLink$Column <- paste(\"my question text here with this value\", 203)\n\n# Text box drill\nr$valueLink$Column <- list(\n    list(\"text\" = \"by User\", \"link\" = paste(\"my question with this column\", r$data$Column2)),\n    list(\"text\" = \"by Company\", \"link\" = paste(\"my other question with this column\", r$data$Column2))\n)\n\n\n\n\nPagination\n\n\nAdds pagination of the specified size.\n\n\nr$paginationSize <- 25\n\n\n\n\nSearchbar\n\n\nBoolean that adds a searchbar to the table(\nFALSE\n by default). \n\n\nr$searchable <- T\n\n\n\n\nAdvanced\n\n\nlooq.responseFrame",
            "title": "R Tutorial"
        },
        {
            "location": "/tutorial/#r-tutorial",
            "text": "This tutorial assumes you don't have any previous knowledge in the Looqbox Package.",
            "title": "R Tutorial"
        },
        {
            "location": "/tutorial/#setup-for-the-tutorial",
            "text": "This documentation's objective is to introduce you to the guidelines for creating organized and efficient R scripts for Looqbox as well as to make you confortable with the looqbox package and with the tool's environment and workflow. In this section we will focus on the creation and editing of the R scripts, so we recomend using Rstudio as the development environment.  You can either write the code in your RStudio Serve, or you can set up a local development environment on your computer and use your local RStudio.",
            "title": "Setup for the Tutorial"
        },
        {
            "location": "/tutorial/#setup-1-rstudio-serve",
            "text": "This is the quickest way to get started!  Open your looqbox instance on port 8787 (usually:  http://localhost:8787 ), enter your  username  and  password  and you're almost ready to go.  Under addins, select Looqbox and enter your admin  username  and  host  (if they're not already there).  \n     It is also recomended to have Looqbox opened on another tab, as your tests will be published there.  You now have everything you need to begin, go ahead to the  basics section .",
            "title": "Setup 1: RStudio Serve"
        },
        {
            "location": "/tutorial/#setup-2-local-development-environment",
            "text": "This setup option requires a little more work at first glance, but it certainly pays off.",
            "title": "Setup 2: Local development environment"
        },
        {
            "location": "/tutorial/#downloads",
            "text": "R:  https://cran.r-project.org/bin/macosx/el-capitan/base/  RStudio:  https://www.rstudio.com/products/rstudio/#Desktop  Local Rstudio configuration file:  Download",
            "title": "Downloads"
        },
        {
            "location": "/tutorial/#configuration",
            "text": "To configure your local Rstudio environment to work with Looqbox's Rprofile, download the files listed above and extract the configuration file in your home directory (the  looqbox-dev  folder should appear).Open the terminal,  cd  to your looqbox-dev directory and execute  setProfile.sh  or run:  bash ~/looqbox-dev/setProfile.sh  To set up your user in RStudio you can either go to the Looqbox Addin, as described in  Setup 1  or edit the  config/R/config.json  file and enter your looqbox username.  See, it wasn't even that hard, and now you're set up to work from your local environment!",
            "title": "Configuration"
        },
        {
            "location": "/tutorial/#basics",
            "text": "",
            "title": "Basics"
        },
        {
            "location": "/tutorial/#script-sctructure",
            "text": "In this section, you'll learn about the structure that your script should be implemented.",
            "title": "Script sctructure"
        },
        {
            "location": "/tutorial/#dependencies",
            "text": "In order to develop a script for Looqbox you should use our Looqbox Package. The package allows you to interact with the interface and help you structure your data to be displayed in our client.  library(looqbox)",
            "title": "Dependencies"
        },
        {
            "location": "/tutorial/#getdata",
            "text": "",
            "title": "get.data"
        },
        {
            "location": "/tutorial/#looqresponse",
            "text": "This block is where your script will start the execution, simulating a main function. Inside it, you should use  looq.lookTag()   to receive the value inside a looqbox tag from the parser.  In this case, we are creating a looqbox standard message box and storing it in msg variable. In the first parameter we're passing a  paste  with the string collected above. The second parameter is the style type to display the box.   Finally, we are creating a looqbox frame to be placed inside a board with  looq.responseFrame() .  looq.response <- function(par) {\n\n  # Receives the value inside a looqbox tag. In this case, we're looking for \n  # $quotes tag and storing it in quotes\n  quotes <- looq.lookTag(\"$quotes\", par)\n\n  # Creates a looqbox standard message box and store it in msg variable. In\n  # the first parameter we're passing a paste with the string collected above\n  # the second parameter is the style type to display the box. \n  msg <- looq.objMessage(\n    paste(\"Hurray, my installation is working!!\\n\", quotes),\n    \"alert-success\"\n  )\n\n  # Creates a looqbox frame to be placed inside a board\n  looq.responseFrame(msg)\n}",
            "title": "looq.response"
        },
        {
            "location": "/tutorial/#test-block",
            "text": "This block is used to test your response from  RStudio , allowing you to simulate our parser and test your script without saving it in Looqbox client. If you have configured your Looqbox addin correctly, you can run your script using  Ctrl + Shift + S  and it will be displayed in your client.  looq.testQuestion(\n  list(\n    \"$quotes\" = \"My test sentence\"\n  )\n)",
            "title": "Test Block"
        },
        {
            "location": "/tutorial/#essential-functions",
            "text": "Now that you have a general understanding of how a script is properly constructed, let us go over a few of the package's most important functions.   NOTE: In this material we'll be working with practical examples. If you wish to understand the full depth and parameters of each of these functions please refer to the package documentation or Looqbox wiki.[ver depois]",
            "title": "Essential functions"
        },
        {
            "location": "/tutorial/#looqlooktag",
            "text": "Normally, the first thing your code will do once it enters your  looq.response() (main) function, is receive information from the parser (in JSON format). From this, we have to extract information such as entities and tags, which will be used as parameters in  get.data() .    looq.lookTag()  acomplishes this task, searching for specific tags and returning their values.   company <- looq.lookTag(\"$company\", par)  In the example above,  looq.lookTag  takes two parameters:   \"$company\" : The entity or pattern it will search for.   par : the parser string, as received by  looq.response(par)     It will then, return the company value and assign it to the variable  company .  If a certain value is an optional parameter for a question,  looq.lookTag()  also accepts a third parameter for setting a default value (should be a list).   date <- looq.lookTag(\"$date\", par, list(c('2018-01-01', '2019-01-01')))  In the code above, if no  $date  value is recognised by the parser it will choose the default, in this case, the period starting yesterday and ending today (whenever that is).",
            "title": "looq.lookTag"
        },
        {
            "location": "/tutorial/#looqmap",
            "text": "This function is, perhaps, the core of the whole script.  looq.map(get.data, date, company)  What it does is fairly simple, the first argument is your  get.data()  function, and the remaining are  variables defined by  looq.lookTag() .    looq.map()  calls the function and passes the variables as arguments to it.  Additionally, it wraps everything in a Looqbox response frame making  get.data 's \noutput intelligible by the interface.",
            "title": "looq.map"
        },
        {
            "location": "/tutorial/#looqsqlexecute",
            "text": "Now that we've got  looq.response  covered, we'll go inside  get.data . Think of it as the backstage of your script, it's where everything is prepared so that your main function keeps neat.  Most of our scripts involve some kind of query to a database,  looq.sqlExecute()  is a funtion that makes this interaction extremely simple.   # We generally store looq.sqlExecute's output in a variable called r\nr <- looq.sqlExecute(\"mySQLDev\", sql, list(dateInt[1], dateInt[2], company, value))\n\n# A simple error test follows the query, checking for data absence\nif(r$rows == 0) return(paste(\"No data found from:\\n\", dateInt[1], \"to\", dateInt[2]))  Normally it will take three arguments:   \"mySQLDB\" : the database's name, as it was registered in the interface under connections.  sql : a string containing the SQL query (we'll cover it in depth)   ... : a list of parameters that will be inserted into the query.   In a simple manner,  looq.sqlExecute  does exatly what the name implies, it executes your query within the database, but more than that, it lets you insert values in the query. Take the following example string:  sql <- \"\n    SELECT\n        EXAMPLE,\n        TEST,\n        FIELD,\n        DATE\n    FROM example.table\n    WHERE 1=1           \n        AND DATE >= DATE_ADD(`1`, INTERVAL +3 HOUR) \n        AND DATE < DATE_ADD(`2`, INTERVAL +3 HOUR)\n        AND COMPANY = `3`\n        AND VALUE = `4`\n    ORDER BY DATE DESC\n\"  The values between backticks ( ` ` )  are recognised by the function and substituted with the variables passed in the third argument of  looq.SQLExecute , in order of appearance.   Say that:  company <- 0\ndateInt <- c('2018-07-09', '2018-08-09')\nvalue <- 1120  The query sent to the database would be:  SELECT\n    EXAMPLE,\n    TEST,\n    FIELD,\n    DATE\nFROM my.exampleDB\nWHERE 1=1\n    AND DATE >= DATE_ADD('2018-07-09', INTERVAL +3 HOUR) \n    AND DATE < DATE_ADD('2018-08-09', INTERVAL +3 HOUR)\n    AND COMPANY = 0\n    AND VALUE = 1120\nORDER BY DATE DESC  Easy right? And it gets better,  looq.sqlExecute  returns a  looq.objTable , an object from the package that is ready to be imported to the interface.",
            "title": "looq.sqlExecute"
        },
        {
            "location": "/tutorial/#looqobjtable-and-its-fields",
            "text": "The most common answer to Looqbox questions comes in the form of tables, but rather than using comon objects as  data.frame  or  tbl  we have developed a special object, which is recognised by the interface and will help you create espoke tables, as it has a number of built-in customization options.  Well go through it's most important parameters here, more advanced options will be treated in the  Advanced Section .",
            "title": "looq.objTable and it's fields"
        },
        {
            "location": "/tutorial/#data",
            "text": "r$data  All of the data retrieved from queries or imported from elsewhere will be available in this variable, which is a  tbl .",
            "title": "Data"
        },
        {
            "location": "/tutorial/#title",
            "text": "You can create a title for your table with  r$title , which will be visible as a header. Another style option is  r$framedTitle . Go ahead and try it out!  The  r$title  format accepts multiple lines, creating subtitles or passing other info as a header,  r$framedTitle  accepts only a string, but you may combine them to create interesting headers.  # Simple title\nr$title <- \"Simple title\"\n\n# Example with framed title\nr$framedTitle <- \"Framed title\"\n\n# Title with date\nr$title <- c(\n    \"My title\",\n    looq.titleWithDate(\"Per\u00edod:\", dateInt)\n)",
            "title": "Title"
        },
        {
            "location": "/tutorial/#style",
            "text": "Add styling to single or multiple columns through  r$value$Style . Good examples are values that turn red if negative but green if positive. The color can be defined as either hex(#fff) or rgb(255,255,255).   \n# Styling single column\nr$valueStyle$Column <- style\n\n# Styling multiple columns at once\nr$valueStyle <- list(\n    \"Column1\" = style,\n    \"Column2\" = style\n)",
            "title": "Style"
        },
        {
            "location": "/tutorial/#formating-my-data",
            "text": "r$valueFormat  lets you format numbers and dates, adding percentages, defining number of decimal points son so on.  You should write the names of each column followed by the format.  r$valueFormat <- list(\n    \"numeric column\" = \"number:2\",\n    \"percent column\" = \"percent:2\"\n)",
            "title": "Formating my data"
        },
        {
            "location": "/tutorial/#total-line",
            "text": "Add a total line to your table, it can be defined for each column. If a column is left blank it will be filled with  -  by default.  r$total <- list(\n    `Column 1` = \"total\",\n    `Column 2` = sum(r$data$`Column 2`)\n)",
            "title": "Total line"
        },
        {
            "location": "/tutorial/#drill-down",
            "text": "To add drill down options that link to other scripts, you should use  r$ValueLink$[Your Column Here] . The question text will be posted as a new question, efectively linking the scripts together.   Using  paste  or  paste0  we can ad variables or values to the link, or, as you can see below, even add values from within the table, by pasting the desired  r$data$column .   The  \"text\"  parameter will add a title to your link, which is essential when multiple drills are made from the same column.  # Simple drill\nr$valueLink$Column <- \"my question text here\"\n\n# Simple drill with variable\nr$valueLink$Column <- paste(\"my question text here with this value\", 203)\n\n# Text box drill\nr$valueLink$Column <- list(\n    list(\"text\" = \"by User\", \"link\" = paste(\"my question with this column\", r$data$Column2)),\n    list(\"text\" = \"by Company\", \"link\" = paste(\"my other question with this column\", r$data$Column2))\n)",
            "title": "Drill Down"
        },
        {
            "location": "/tutorial/#pagination",
            "text": "Adds pagination of the specified size.  r$paginationSize <- 25",
            "title": "Pagination"
        },
        {
            "location": "/tutorial/#searchbar",
            "text": "Boolean that adds a searchbar to the table( FALSE  by default).   r$searchable <- T",
            "title": "Searchbar"
        },
        {
            "location": "/tutorial/#advanced",
            "text": "",
            "title": "Advanced"
        },
        {
            "location": "/tutorial/#looqresponseframe",
            "text": "",
            "title": "looq.responseFrame"
        }
    ]
}